---
import BaseHead from '../components/BaseHead.astro';
import CornersWithCrosses from '../components/CornersWithCrosses.astro';
---

<!doctype html>
<html lang="en" class="antialiased break-words">
    <head>
        <BaseHead title="Game of Life" description="Conway's Game of Life - Full Screen Interactive Version" />
        <script>
            // Fast theme initialization
            function applyTheme(themeId, isDark) {
                document.documentElement.setAttribute('data-theme', themeId);
                document.documentElement.classList.toggle('dark', isDark);
            }

            const savedMode = localStorage.getItem('theme-mode') || 'light';
            const savedTheme = localStorage.getItem('theme-id') || 'void';
            
            applyTheme(savedTheme, savedMode === 'dark');

            // Color animation for Prism theme
            let mainHue = 0;
            function updateColorSystem() {
                mainHue = (mainHue + 0.25) % 360;
                document.documentElement.style.setProperty('--main-hue', mainHue.toFixed(2));
                requestAnimationFrame(updateColorSystem);
            }
            updateColorSystem();
        </script>
    </head>
    <body class="bg-secondary text-main overflow-hidden">
        <div class="fixed inset-0 flex bg-secondary text-main">
            <!-- Main Game Area -->
            <div id="gameArea" class="flex-1 relative transition-all duration-300">
                <!-- Top Controls Bar -->
                <div class="absolute top-0 left-0 right-0 z-20 flex justify-between items-center p-4">
                    <!-- Left controls -->
                    <div class="flex items-center gap-2">
                        <a
                            href="/"
                            class="w-8 h-8 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  font-mono text-xs font-semibold flex items-center justify-center"
                            title="Back to Home"
                        >
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="m15 18-6-6 6-6"/>
                            </svg>
                        </a>
                        <button
                            id="sidebarToggle"
                            class="w-8 h-8 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  font-mono text-xs font-semibold flex items-center justify-center"
                            title="Toggle Sidebar"
                        >
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect width="18" height="18" x="3" y="3" rx="2"/>
                                <path d="M9 3v18"/>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- Game Canvas Container -->
                <div class="absolute inset-0">
                    <CornersWithCrosses class="border border-dotted w-full h-full relative">
                        <canvas
                            id="gameOfLifeCanvas"
                            class="w-full h-full cursor-crosshair bg-transparent"
                        ></canvas>
                    
                        <!-- Pattern name display -->
                        <div id="patternName" class="absolute top-16 left-4 text-main font-mono text-sm font-semibold opacity-0 transition-opacity duration-300 z-10"></div>
                        
                        <!-- Content Actions (bottom-left) -->
                        <div class="absolute bottom-4 left-4 flex items-center gap-2 z-10">
                            <button
                                id="clearBtn"
                                class="w-8 h-8 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  font-mono text-xs font-semibold flex items-center justify-center"
                                title="Clear Grid"
                            >
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M18 6 6 18"/>
                                    <path d="m6 6 12 12"/>
                                </svg>
                            </button>
                            <button
                                id="randomBtn"
                                class="w-8 h-8 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  font-mono text-xs font-semibold flex items-center justify-center"
                                title="Random Noise"
                            >
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <rect width="16" height="16" x="4" y="4" rx="2" ry="2"/>
                                    <circle cx="8" cy="8" r="0.5" fill="currentColor"/>
                                    <circle cx="16" cy="8" r="0.5" fill="currentColor"/>
                                    <circle cx="12" cy="12" r="0.5" fill="currentColor"/>
                                    <circle cx="8" cy="16" r="0.5" fill="currentColor"/>
                                    <circle cx="16" cy="16" r="0.5" fill="currentColor"/>
                                </svg>
                            </button>
                        </div>

                        <!-- Simulation Controls (bottom-right) -->
                        <div class="absolute bottom-4 right-4 flex items-center gap-2 z-10">
                            <button
                                id="trailBtn"
                                class="w-8 h-8 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  font-mono text-xs font-semibold flex items-center justify-center"
                                title="Toggle Ghost Trail"
                            >
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M9 10h.01"/>
                                    <path d="M15 10h.01"/>
                                    <path d="M12 2a8 8 0 0 0-8 8v12l3-3 2.5 2.5L12 19l2.5 2.5L17 19l3 3V10a8 8 0 0 0-8-8z"/>
                                </svg>
                            </button>
                            <button
                                id="speedToggle"
                                class="px-2 py-1 h-8 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  font-mono text-xs font-semibold flex items-center justify-center"
                                title="Speed Control"
                            >
                                <svg width="40" height="12" viewBox="0 0 40 12" style="display: block;">
                                    <polygon points="2,2 8,6 2,10" fill="var(--color-main)" stroke="var(--color-main)" stroke-width="1"/>
                                    <polygon points="12,2 18,6 12,10" fill="var(--color-main)" stroke="var(--color-main)" stroke-width="1"/>
                                    <polygon points="22,2 28,6 22,10" fill="var(--color-secondary)" stroke="var(--color-main)" stroke-width="1"/>
                                    <polygon points="32,2 38,6 32,10" fill="var(--color-secondary)" stroke="var(--color-main)" stroke-width="1"/>
                                </svg>
                            </button>
                            <button
                                id="playPauseBtn"
                                class="w-8 h-8 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  font-mono text-xs font-semibold flex items-center justify-center"
                                title="Play/Pause"
                            >
                                ⏸
                            </button>
                        </div>
                    </CornersWithCrosses>
                </div>
            </div>

            <!-- Sidebar -->
            <div id="sidebar" class="w-80 max-w-[350px] bg-secondary border-l border-main overflow-y-auto transition-transform duration-300 transform translate-x-0" style="min-width: 320px;">
                <div class="p-6 space-y-6">
                    <!-- Sidebar Header with Close Button -->
                    <div class="flex justify-between items-center border-b border-main pb-4">
                        <div>
                            <h1 class="text-xl font-bold font-mono text-main">GAME OF LIFE</h1>
                            <p class="text-sm text-main mt-2 font-mono">Conway's cellular automaton</p>
                        </div>
                        <button
                            id="sidebarClose"
                            class="w-6 h-6 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  font-mono text-xs font-semibold flex items-center justify-center"
                            title="Close Sidebar"
                        >
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M18 6 6 18"/>
                                <path d="m6 6 12 12"/>
                            </svg>
                        </button>
                    </div>

                    <!-- Pattern Selector -->
                    <div>
                        <h2 class="text-sm font-bold font-mono text-main mb-3">PATTERNS</h2>
                        <div class="grid grid-cols-2 gap-2">
                            <button class="pattern-btn w-full p-3 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  text-xs font-mono font-semibold text-left" data-pattern="glider">
                                GLIDER
                            </button>
                            <button class="pattern-btn w-full p-3 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  text-xs font-mono font-semibold text-left" data-pattern="blinker">
                                BLINKER
                            </button>
                            <button class="pattern-btn w-full p-3 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  text-xs font-mono font-semibold text-left" data-pattern="toad">
                                TOAD
                            </button>
                            <button class="pattern-btn w-full p-3 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  text-xs font-mono font-semibold text-left" data-pattern="beacon">
                                BEACON
                            </button>
                            <button class="pattern-btn w-full p-3 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  text-xs font-mono font-semibold text-left" data-pattern="pulsar">
                                PULSAR
                            </button>
                            <button class="pattern-btn w-full p-3 border border-main bg-secondary text-main hover:bg-main hover:text-secondary  text-xs font-mono font-semibold text-left" data-pattern="gosper">
                                GOSPER GUN
                            </button>
                        </div>
                    </div>

                    <!-- Pattern Information -->
                    <div id="patternInfo" class="border border-main p-4">
                        <h3 class="text-sm font-bold font-mono text-main mb-2">PATTERN INFO</h3>
                        <div id="patternDetails" class="text-xs font-mono text-main">
                            <p>Select a pattern to see information about it.</p>
                        </div>
                    </div>

                    <!-- Rules -->
                    <div class="border border-main p-4">
                        <h3 class="text-sm font-bold font-mono text-main mb-2">RULES</h3>
                        <div class="text-xs font-mono text-main space-y-2">
                            <p>• Live cell with &lt; 2 neighbors dies</p>
                            <p>• Live cell with 2-3 neighbors survives</p>
                            <p>• Live cell with &gt; 3 neighbors dies</p>
                            <p>• Dead cell with 3 neighbors becomes alive</p>
                        </div>
                    </div>

                    <!-- Controls -->
                    <div class="border border-main p-4">
                        <h3 class="text-sm font-bold font-mono text-main mb-2">CONTROLS</h3>
                        <div class="text-xs font-mono text-main space-y-1">
                            <p>• Click/drag to draw cells</p>
                            <p>• Space: Play/Pause</p>
                            <p>• C: Clear grid</p>
                            <p>• R: Random noise</p>
                            <p>• T: Toggle ghost trail</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </body>
</html>

<script>
    // Pattern information data
    const patternInfo = {
        glider: {
            name: "Glider",
            description: "A simple moving pattern that travels diagonally across the grid. It's one of the most famous patterns in Conway's Game of Life.",
            size: "3×3",
            type: "Spaceship",
            period: "4"
        },
        blinker: {
            name: "Blinker",
            description: "The simplest oscillator pattern. It alternates between horizontal and vertical orientations every generation.",
            size: "3×1",
            type: "Oscillator",
            period: "2"
        },
        toad: {
            name: "Toad",
            description: "A simple period-2 oscillator that looks like a toad hopping back and forth.",
            size: "4×2",
            type: "Oscillator",
            period: "2"
        },
        beacon: {
            name: "Beacon",
            description: "A period-2 oscillator that flickers like a beacon light. Consists of two blocks that turn on and off alternately.",
            size: "4×4",
            type: "Oscillator",
            period: "2"
        },
        pulsar: {
            name: "Pulsar",
            description: "A large period-3 oscillator that pulses outward and inward in a symmetric pattern.",
            size: "13×13",
            type: "Oscillator",
            period: "3"
        },
        gosper: {
            name: "Gosper Gun",
            description: "The first discovered gun pattern that continuously produces gliders. It has a period of 30 and creates a new glider every 30 generations.",
            size: "36×9",
            type: "Gun",
            period: "30"
        }
    };

    // Game of Life class for full-screen version
    class FullScreenGameOfLife {
        constructor() {
            this.canvas = document.getElementById('gameOfLifeCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.cellSize = 12;
            this.speed = 150;
            this.speedLevel = 2;
            this.isRunning = true;
            this.isDrawing = false;
            this.lastUpdateTime = 0;
            this.animationId = null;
            this.lastDrawPos = null;
            this.drawMode = null;
            this.trailEnabled = false;
            this.generationHistory = [];
            this.maxTrailGenerations = 5;
            this.gap = 1;
            
            // Famous Game of Life patterns
            this.patterns = {
                glider: [
                    [0, 1, 0],
                    [0, 0, 1],
                    [1, 1, 1]
                ],
                blinker: [
                    [1, 1, 1]
                ],
                toad: [
                    [0, 1, 1, 1],
                    [1, 1, 1, 0]
                ],
                beacon: [
                    [1, 1, 0, 0],
                    [1, 1, 0, 0],
                    [0, 0, 1, 1],
                    [0, 0, 1, 1]
                ],
                pulsar: [
                    [0,0,1,1,1,0,0,0,1,1,1,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [0,0,1,1,1,0,0,0,1,1,1,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,1,1,1,0,0,0,1,1,1,0,0],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [1,0,0,0,0,1,0,1,0,0,0,0,1],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,1,1,1,0,0,0,1,1,1,0,0]
                ],
                gosper: [
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                    [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1],
                    [1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
                ]
            };
            
            this.setupCanvas();
            this.initializeGrid();
            this.setupEventListeners();
            this.setupPatternSelector();
            this.setupSidebarToggle();
            this.updatePlayPauseIcon();
            this.updateSpeedIcon();
            this.startRenderLoop();
        }
        
        setupCanvas() {
            this.resizeCanvas();
            this.ctx = this.canvas.getContext('2d');
            this.ctx.imageSmoothingEnabled = false;
            
            // Listen for window resize
            window.addEventListener('resize', () => {
                this.resizeCanvas();
            });
        }
        
        resizeCanvas() {
            const gameArea = document.getElementById('gameArea');
            const rect = gameArea.getBoundingClientRect();
            
            // Set canvas size to fill available space
            this.canvas.width = rect.width;
            this.canvas.height = rect.height;
            
            // Calculate grid dimensions
            this.cols = Math.floor(this.canvas.width / this.cellSize);
            this.rows = Math.floor(this.canvas.height / this.cellSize);
            
            // Reinitialize grid if dimensions changed
            if (this.grid && (this.grid.length !== this.rows || this.grid[0]?.length !== this.cols)) {
                this.initializeGrid();
            }
        }
        
        initializeGrid() {
            this.grid = [];
            this.nextGrid = [];
            
            for (let i = 0; i < this.rows; i++) {
                this.grid[i] = [];
                this.nextGrid[i] = [];
                for (let j = 0; j < this.cols; j++) {
                    this.grid[i][j] = { alive: false };
                    this.nextGrid[i][j] = { alive: false };
                }
            }
        }
        
        setupEventListeners() {
            // Canvas mouse events
            this.canvas.addEventListener('mousedown', (e) => {
                e.preventDefault();
                this.isDrawing = true;
                this.drawMode = null;
                this.lastDrawPos = null;
                this.handleCanvasClick(e);
            });
            
            this.canvas.addEventListener('mousemove', (e) => {
                e.preventDefault();
                if (this.isDrawing) {
                    this.handleCanvasClick(e);
                }
            });
            
            this.canvas.addEventListener('mouseup', (e) => {
                e.preventDefault();
                this.isDrawing = false;
                this.drawMode = null;
                this.lastDrawPos = null;
            });
            
            this.canvas.addEventListener('mouseleave', () => {
                this.isDrawing = false;
                this.drawMode = null;
                this.lastDrawPos = null;
            });
            
            this.canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
            
            this.canvas.addEventListener('dragstart', (e) => {
                e.preventDefault();
            });
            
            // Control buttons
            document.getElementById('playPauseBtn')?.addEventListener('click', () => {
                this.togglePlayPause();
            });
            
            document.getElementById('clearBtn')?.addEventListener('click', () => {
                this.clearGrid();
            });
            
            document.getElementById('randomBtn')?.addEventListener('click', () => {
                this.randomizeGrid();
            });
            
            document.getElementById('speedToggle')?.addEventListener('click', () => {
                this.toggleSpeed();
            });
            
            document.getElementById('trailBtn')?.addEventListener('click', () => {
                this.toggleTrail();
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                switch(e.key.toLowerCase()) {
                    case ' ':
                        e.preventDefault();
                        this.togglePlayPause();
                        break;
                    case 'c':
                        this.clearGrid();
                        break;
                    case 'r':
                        this.randomizeGrid();
                        break;
                    case 't':
                        this.toggleTrail();
                        break;
                }
            });
        }

        setupPatternSelector() {
            const patternButtons = document.querySelectorAll('.pattern-btn');
            const patternDetails = document.getElementById('patternDetails');
            
            patternButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const patternKey = button.dataset.pattern;
                    this.placePattern(patternKey);
                    this.showPatternInfo(patternKey);
                });
            });
        }

        setupSidebarToggle() {
            const sidebar = document.getElementById('sidebar');
            const gameArea = document.getElementById('gameArea'); 
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarClose = document.getElementById('sidebarClose');
            
            let sidebarOpen = true;
            
            const toggleSidebar = () => {
                sidebarOpen = !sidebarOpen;
                
                if (sidebarOpen) {
                    sidebar.style.transform = 'translateX(0)';
                    gameArea.style.marginRight = '0';
                } else {
                    sidebar.style.transform = 'translateX(100%)';
                    gameArea.style.marginRight = '-350px';
                }
                
                // Resize canvas after sidebar animation
                setTimeout(() => {
                    this.resizeCanvas();
                }, 300);
            };
            
            sidebarToggle?.addEventListener('click', toggleSidebar);
            sidebarClose?.addEventListener('click', toggleSidebar);
        }

        showPatternInfo(patternKey) {
            const patternDetails = document.getElementById('patternDetails');
            const info = patternInfo[patternKey];
            
            if (info && patternDetails) {
                patternDetails.innerHTML = `
                    <p class="font-semibold mb-2">${info.name}</p>
                    <p class="mb-2">${info.description}</p>
                    <div class="space-y-1">
                        <p><span class="font-semibold">Size:</span> ${info.size}</p>
                        <p><span class="font-semibold">Type:</span> ${info.type}</p>
                        <p><span class="font-semibold">Period:</span> ${info.period}</p>
                    </div>
                `;
            }
        }

        placePattern(patternKey) {
            const pattern = this.patterns[patternKey];
            if (!pattern) return;
            
            // Clear grid first
            this.clearGrid();
            
            // Place pattern in center
            const startRow = Math.floor((this.rows - pattern.length) / 2);
            const startCol = Math.floor((this.cols - pattern[0].length) / 2);
            
            for (let i = 0; i < pattern.length; i++) {
                for (let j = 0; j < pattern[i].length; j++) {
                    const row = startRow + i;
                    const col = startCol + j;
                    if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
                        this.grid[row][col].alive = pattern[i][j] === 1;
                    }
                }
            }

            // Show pattern name
            this.showPatternName(patternInfo[patternKey]?.name || patternKey.toUpperCase());
        }

        showPatternName(name) {
            const nameElement = document.getElementById('patternName');
            if (nameElement) {
                nameElement.textContent = name;
                nameElement.style.opacity = '1';
                
                setTimeout(() => {
                    nameElement.style.opacity = '0';
                }, 3000);
            }
        }
        
        handleCanvasClick(e) {
            const rect = this.canvas.getBoundingClientRect();
            const scaleX = this.canvas.width / rect.width;
            const scaleY = this.canvas.height / rect.height;
            
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            
            const col = Math.floor(x / this.cellSize);
            const row = Math.floor(y / this.cellSize);
            
            if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
                const currentPos = { row, col };
                
                if (this.drawMode === null) {
                    this.drawMode = this.grid[row][col].alive ? 'deactivate' : 'activate';
                }
                
                if (this.lastDrawPos) {
                    this.drawLine(this.lastDrawPos, currentPos);
                } else {
                    this.toggleCell(row, col);
                }
                
                this.lastDrawPos = currentPos;
            }
        }
        
        drawLine(start, end) {
            const dx = Math.abs(end.col - start.col);
            const dy = Math.abs(end.row - start.row);
            const sx = (start.col < end.col) ? 1 : -1;
            const sy = (start.row < end.row) ? 1 : -1;
            let err = dx - dy;
            
            let currentCol = start.col;
            let currentRow = start.row;
            
            while (true) {
                this.toggleCell(currentRow, currentCol);
                
                if (currentCol === end.col && currentRow === end.row) break;
                
                const e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    currentCol += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    currentRow += sy;
                }
            }
        }
        
        toggleCell(row, col) {
            if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
                if (this.drawMode === 'activate') {
                    this.grid[row][col].alive = true;
                } else if (this.drawMode === 'deactivate') {
                    this.grid[row][col].alive = false;
                }
            }
        }
        
        togglePlayPause() {
            this.isRunning = !this.isRunning;
            this.updatePlayPauseIcon();
            
            if (this.isRunning) {
                this.lastUpdateTime = performance.now();
            }
        }
        
        clearGrid() {
            for (let i = 0; i < this.rows; i++) {
                for (let j = 0; j < this.cols; j++) {
                    this.grid[i][j].alive = false;
                }
            }
        }
        
        randomizeGrid() {
            for (let i = 0; i < this.rows; i++) {
                for (let j = 0; j < this.cols; j++) {
                    this.grid[i][j].alive = Math.random() < 0.15;
                }
            }
        }
        
        toggleSpeed() {
            this.speedLevel = (this.speedLevel % 4) + 1;
            const speeds = [300, 150, 75, 40];
            this.speed = speeds[this.speedLevel - 1];
            this.updateSpeedIcon();
        }
        
        getSpeedIcon(level) {
            const playButtons = [];
            for (let i = 1; i <= 4; i++) {
                const filled = i <= level;
                const x = (i-1) * 8;
                playButtons.push(`
                    <polygon 
                        points="${x+2},2 ${x+2},10 ${x+6},6" 
                        fill="${filled ? 'var(--color-main)' : 'none'}" 
                        stroke="var(--color-main)" 
                        stroke-width="1"
                    />
                `);
            }
            
            return `
                <svg width="32" height="12" viewBox="0 0 32 12" style="display: block;">
                    ${playButtons.join('')}
                </svg>
            `;
        }
        
        updatePlayPauseIcon() {
            const btn = document.getElementById('playPauseBtn');
            if (btn) {
                btn.textContent = this.isRunning ? '⏸' : '▶';
            }
        }
        
        updateSpeedIcon() {
            const btn = document.getElementById('speedToggle');
            if (btn) {
                btn.innerHTML = this.getSpeedIcon(this.speedLevel);
            }
        }
        
        toggleTrail() {
            this.trailEnabled = !this.trailEnabled;
            
            if (!this.trailEnabled) {
                this.generationHistory = [];
            }
            
            const btn = document.getElementById('trailBtn');
            if (btn) {
                if (this.trailEnabled) {
                    btn.style.backgroundColor = 'var(--color-main)';
                    btn.style.color = 'var(--color-secondary)';
                } else {
                    btn.style.backgroundColor = 'var(--color-secondary)';
                    btn.style.color = 'var(--color-main)';
                }
            }
        }
        
        countNeighbors(row, col) {
            let count = 0;
            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    if (i === 0 && j === 0) continue;
                    
                    const newRow = row + i;
                    const newCol = col + j;
                    
                    if (newRow >= 0 && newRow < this.rows && newCol >= 0 && newCol < this.cols) {
                        if (this.grid[newRow][newCol].alive) count++;
                    }
                }
            }
            return count;
        }
        
        updateGrid() {
            if (this.trailEnabled) {
                this.saveGenerationForTrail();
            }
            
            for (let i = 0; i < this.rows; i++) {
                for (let j = 0; j < this.cols; j++) {
                    const neighbors = this.countNeighbors(i, j);
                    const currentCell = this.grid[i][j];
                    
                    if (currentCell.alive) {
                        this.nextGrid[i][j].alive = neighbors === 2 || neighbors === 3;
                    } else {
                        this.nextGrid[i][j].alive = neighbors === 3;
                    }
                }
            }
            
            [this.grid, this.nextGrid] = [this.nextGrid, this.grid];
        }
        
        saveGenerationForTrail() {
            const gridCopy = [];
            for (let i = 0; i < this.rows; i++) {
                gridCopy[i] = [];
                for (let j = 0; j < this.cols; j++) {
                    gridCopy[i][j] = { alive: this.grid[i][j].alive };
                }
            }
            
            this.generationHistory.push(gridCopy);
            
            if (this.generationHistory.length > this.maxTrailGenerations) {
                this.generationHistory.shift();
            }
        }
        
        draw() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            
            const computedStyle = getComputedStyle(document.documentElement);
            const mainColor = computedStyle.getPropertyValue('--color-main').trim() || '#000000';
            
            // Draw grid lines
            this.ctx.strokeStyle = mainColor;
            this.ctx.globalAlpha = 0.1;
            this.ctx.lineWidth = 0.5;
            
            for (let j = 0; j <= this.cols; j++) {
                const x = j * this.cellSize;
                this.ctx.beginPath();
                this.ctx.moveTo(x, 0);
                this.ctx.lineTo(x, this.canvas.height);
                this.ctx.stroke();
            }
            
            for (let i = 0; i <= this.rows; i++) {
                const y = i * this.cellSize;
                this.ctx.beginPath();
                this.ctx.moveTo(0, y);
                this.ctx.lineTo(this.canvas.width, y);
                this.ctx.stroke();
            }
            
            // Draw trail effect
            if (this.trailEnabled && this.generationHistory.length > 0) {
                for (let gen = 0; gen < this.generationHistory.length; gen++) {
                    const generation = this.generationHistory[gen];
                    const opacity = 0.1 + (gen / this.generationHistory.length) * 0.4;
                    this.ctx.globalAlpha = opacity;
                    this.ctx.fillStyle = mainColor;
                    
                    for (let i = 0; i < this.rows && i < generation.length; i++) {
                        for (let j = 0; j < this.cols && j < generation[i].length; j++) {
                            if (generation[i][j].alive) {
                                const x = j * this.cellSize + this.gap;
                                const y = i * this.cellSize + this.gap;
                                const size = this.cellSize - (this.gap * 2);
                                this.ctx.fillRect(x, y, size, size);
                            }
                        }
                    }
                }
            }
            
            // Draw current generation
            this.ctx.globalAlpha = 1.0;
            this.ctx.fillStyle = mainColor;
            
            for (let i = 0; i < this.rows; i++) {
                for (let j = 0; j < this.cols; j++) {
                    if (this.grid[i][j].alive) {
                        const x = j * this.cellSize + this.gap;
                        const y = i * this.cellSize + this.gap;
                        const size = this.cellSize - (this.gap * 2);
                        this.ctx.fillRect(x, y, size, size);
                    }
                }
            }
        }
        
        startRenderLoop() {
            const renderFrame = (currentTime) => {
                if (this.isRunning && currentTime - this.lastUpdateTime >= this.speed) {
                    this.updateGrid();
                    this.lastUpdateTime = currentTime;
                }
                
                this.draw();
                this.animationId = requestAnimationFrame(renderFrame);
            };
            
            this.animationId = requestAnimationFrame(renderFrame);
        }
    }

    // Initialize the game when the DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
        new FullScreenGameOfLife();
    });

    // Handle theme changes
    document.addEventListener('astro:after-swap', () => {
        new FullScreenGameOfLife();
    });
</script>

<style>
    /* Ensure proper canvas sizing */
    #gameOfLifeCanvas {
        display: block;
        max-width: 100%;
        height: auto;
    }
</style>