---
import { AstroFont } from 'astro-font';
import BaseHead, { type Props as HeadProps } from '../components/BaseHead.astro';
import Navbar from '../components/Navbar.astro';
import Footer from "../components/Footer.astro"
import WaveDivider from '../components/WaveDivider.astro';
import NorwegianDisclaimer from '../components/NorwegianDisclaimer.astro';
import FaviconManager from '../components/FaviconManager.tsx';
import { type Language } from '../i18n/ui';
import { getTranslations } from '../i18n/utils';
import { themes } from '../data/themes.js';

export interface Props extends HeadProps {
    showHeader?: boolean;
    headerTitle?: string | null;
    headerSubtitle?: string | null;
    lang?: Language;
    showGameOfLife?: boolean;
}

const {
    showHeader = true,
    headerTitle = null,
    headerSubtitle = null,
    lang = 'es',
    showGameOfLife = false,
    ...head
} = Astro.props;

// Generate theme data for the client script
const validThemes = themes.map(t => t.id);
const themeColors = themes.reduce((acc, theme) => {
    acc[theme.id] = {
        colorful: theme.colorful, // Using backwards compatibility getters
        contrasty: theme.contrasty
    };
    return acc;
}, {} as Record<string, { colorful: string; contrasty: string }>);

const defaultTheme = themes[0];
const defaultColorful = defaultTheme.colorful;
const defaultContrasty = defaultTheme.contrasty;
const defaultThemeId = defaultTheme.id;

const turnstileSiteKey = import.meta.env.PUBLIC_TURNSTILE_SITE_KEY?.trim();

// Get translations for theme toasts
const t = getTranslations(lang);
const themeMessages = {
    unlocked: t('theme.toast.unlocked'),
    locked: t('theme.toast.locked'),
    company: t('theme.toast.company'),
    companyHidden: t('theme.toast.companyHidden')
};


declare global {
    interface Window {
        __THEME_ID__?: string;
        __THEME_MODE__?: string;
        __THEME_READY__?: boolean;
    }
}
---

<!doctype html>
<html lang={lang} class="antialiased break-words">
    <head>
        <AstroFont
            config={[
                {
                    name: 'Atkinson Hyperlegible',
                    src: [
                        {
                            weight: '100 900',
                            style: 'normal',
                            path: '/fonts/Atkinson_Hyperlegible_Next/AtkinsonHyperlegibleNext-VariableFont_wght.ttf'
                        },
                        {
                            weight: '100 900',
                            style: 'italic',
                            path: '/fonts/Atkinson_Hyperlegible_Next/AtkinsonHyperlegibleNext-Italic-VariableFont_wght.ttf'
                        }
                    ],
                    preload: true,
                    display: 'swap',
                    selector: 'body',
                    fallback: 'sans-serif'
                },
                {
                    name: 'Space Grotesk',
                    src: [
                        {
                            weight: '300 700',
                            style: 'normal',
                            path: '/fonts/Space_Grotesk/SpaceGrotesk-VariableFont_wght.ttf'
                        }
                    ],
                    preload: true,
                    display: 'swap',
                    selector: 'h1, h2, h3, h4, h5, h6',
                    fallback: 'sans-serif'
                },
                {
                    name: 'Atkinson Hyperlegible Mono',
                    src: [
                        {
                            weight: '100 700',
                            style: 'normal',
                            path: '/fonts/Atkinson_Hyperlegible_Mono/AtkinsonHyperlegibleMono-VariableFont_wght.ttf'
                        },
                        {
                            weight: '100 700',
                            style: 'italic',
                            path: '/fonts/Atkinson_Hyperlegible_Mono/AtkinsonHyperlegibleMono-Italic-VariableFont_wght.ttf'
                        }
                    ],
                    preload: true,
                    display: 'swap',
                    selector: 'code, pre, .mono',
                    fallback: 'monospace'
                }
            ]}
        />

        <!-- BLOCKING theme script - runs BEFORE any rendering to prevent flash -->
        <script is:inline define:vars={{ validThemes, themeColors, defaultColorful, defaultContrasty, defaultThemeId }}>
            // BLOCKING theme application - runs synchronously before any CSS
            (function() {
                // Create reusable theme application function
                function applyThemeInstantly() {
                    const html = document.documentElement;

                    // Get theme from localStorage immediately (synchronously)
                    let savedTheme, savedMode;
                    try {
                        savedTheme = localStorage.getItem('theme-id');
                        savedMode = localStorage.getItem('theme-mode');
                    } catch (e) {
                        // localStorage unavailable - use defaults
                        savedTheme = null;
                        savedMode = null;
                    }

                    // Determine theme immediately
                    let themeId = defaultThemeId;
                    if (savedTheme && themeColors[savedTheme]) {
                        themeId = savedTheme;
                    } else if (savedTheme && !themeColors[savedTheme]) {
                        // Theme doesn't exist anymore, clear it
                        try {
                            localStorage.removeItem('theme-id');
                        } catch (e) {
                            // Ignore error
                        }
                    }
                    const mode = savedMode || 'system';

                    // Get theme colors from embedded data
                    const theme = themeColors[themeId] || {
                        colorful: defaultColorful,
                        contrasty: defaultContrasty
                    };

                    // Determine dark mode immediately
                    let isDark = false;
                    if (mode === 'system') {
                        isDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                    } else {
                        isDark = mode === 'dark';
                    }

                    // Apply ALL theme properties SIMULTANEOUSLY to prevent flash
                    html.setAttribute('data-theme', themeId);
                    html.classList.toggle('dark', isDark);

                    // Set ALL CSS variables in one batch
                    const mainColor = isDark ? theme.colorful : theme.contrasty;
                    const secondaryColor = isDark ? theme.contrasty : theme.colorful;

                    html.style.setProperty('--theme-colorful', theme.colorful);
                    html.style.setProperty('--theme-contrasty', theme.contrasty);
                    html.style.setProperty('--color-main', mainColor);
                    html.style.setProperty('--color-secondary', secondaryColor);

                    // Store for React components
                    window.__THEME_ID__ = themeId;
                    window.__THEME_MODE__ = mode;
                    window.__THEME_READY__ = true;
                }

                // Apply theme IMMEDIATELY (blocks rendering)
                applyThemeInstantly();

                // Re-apply theme instantly before View Transitions start
                document.addEventListener('astro:before-preparation', applyThemeInstantly);
                document.addEventListener('astro:page-load', applyThemeInstantly);

                // Store the function globally so it can be called from anywhere
                window.__APPLY_THEME_INSTANTLY__ = applyThemeInstantly;
            })();
        </script>
        
    
 
        
        <BaseHead {...head} lang={lang} />
        
        <!-- Selection color animator - defer to reduce blocking -->
        <script>
            import { startGlobalSelectionAnimation } from '@/utils/globalSelectionAnimator';
            import { debugLogger } from '@/utils/debug-logger';

            // Use idle callback for non-critical animation
            function initSelectionAnimation() {
                try {
                    startGlobalSelectionAnimation();
                } catch (err) {
                    debugLogger.warn('Selection animator failed to load:', err);
                }
            }

            if ('requestIdleCallback' in window) {
                requestIdleCallback(initSelectionAnimation, { timeout: 2000 });
            } else {
                setTimeout(initSelectionAnimation, 100);
            }
        </script>
        
        <!-- Additional theme persistence for View Transitions -->
        <script is:inline>
            // Ensure theme persists during View Transitions
            document.addEventListener('astro:before-preparation', function() {
                // Apply theme immediately when preparing for transition
                if (window.__APPLY_THEME_INSTANTLY__) {
                    window.__APPLY_THEME_INSTANTLY__();
                }
            });

            document.addEventListener('astro:after-preparation', function() {
                // Apply theme immediately after transition preparation
                if (window.__APPLY_THEME_INSTANTLY__) {
                    window.__APPLY_THEME_INSTANTLY__();
                }
            });
        </script>


        <!-- Konami Code Integration - defer to reduce blocking -->
        <script is:inline define:vars={{ themeMessages }}>
            // Store theme messages for use in module script
            window.__THEME_MESSAGES__ = themeMessages;
        </script>

        <!-- Footer translations - expose to client scripts -->
        <script is:inline define:vars={{ lang }}>
            // Store all translations for the current language for use in footer scripts
            window.__ASTRO_I18N__ = window.__ASTRO_I18N__ || {};

            // Import translation function on the client
            const translations = {
                'es': {
                    'footer.motion.activated': 'Activado',
                    'footer.motion.deactivated': 'Desactivado'
                },
                'en': {
                    'footer.motion.activated': 'Activated',
                    'footer.motion.deactivated': 'Deactivated'
                },
                'no': {
                    'footer.motion.activated': 'Aktivert',
                    'footer.motion.deactivated': 'Deaktivert'
                }
            };

            window.__ASTRO_I18N__[lang] = translations[lang];
        </script>

        <script>
            import { initKonami, resetKonami } from '@/utils/konami-init';

            // Initialize Konami code after DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => setTimeout(initKonami, 50), { once: true });
            } else {
                setTimeout(initKonami, 50);
            }

            // Re-initialize after page transitions
            document.addEventListener('astro:page-load', () => {
                resetKonami();
                setTimeout(initKonami, 50);
            });
        </script>

        <!-- Company Theme Query Param Detection - only run if params exist -->
        <script>
            import { checkCompanyQueryParams } from '@/utils/company-theme-init';

            // Quick check if any params exist before loading heavy modules
            const hasQueryParams = window.location.search.length > 0;
            if (hasQueryParams) {
                // Check on page load
                checkCompanyQueryParams();
            }

            // Also check on navigation (for SPAs)
            document.addEventListener('astro:page-load', () => {
                if (window.location.search.length > 0) {
                    checkCompanyQueryParams();
                }
            });
        </script>
        
        <style is:inline>
            /* View Transitions - instant to prevent flash */
            ::view-transition-old(root),
            ::view-transition-new(root) {
                animation: none;
                animation-duration: 0s;
            }

            /* Disable view transition for root to prevent theme flash */
            :root {
                view-transition-name: none;
            }

            /* Prevent navbar from participating in theme view transitions */
            /* ::view-transition-old(navbar),
            ::view-transition-new(navbar) {
                animation: none;
                animation-duration: 0s;
            } */

            /* Instant color and background changes - no transition delay */
            html, body, * {
                transition-property: transform, opacity, filter;
                transition-duration: inherit;
            }

        </style>
        <script
            src="https://challenges.cloudflare.com/turnstile/v0/api.js"
            async
            defer
        ></script>
    </head>
    <body class="relative bg-main" id="app-body">
        <div class="text-main bg-secondary">

      
        <div class="bg-main w-full h-2"></div> 
        <div class="h-8 !z-100"> 
            <WaveDivider />
        </div>
        <Navbar />
        <FaviconManager client:idle />
        <NorwegianDisclaimer lang={lang} />
        <div class="pt-24 mt-8 mx-auto max-w-[var(--max-w-size)] "> 
            <main class="text-left px-4" id="main-content">
                <slot />
            </main>
        </div> 
        <Footer lang={lang} />
         
           </div>


        {turnstileSiteKey && (
            <div
                id="turnstile-proxy-widget"
                class="cf-turnstile"
                data-sitekey={turnstileSiteKey}
                data-size="invisible"
                hidden
            ></div>
        )}
        {turnstileSiteKey && (
            <script type="module" define:vars={{ turnstileSiteKey }}>
                const siteKey = turnstileSiteKey;
                const endpoint = '/api/worker';
                const state = window.__workerVisitState || (window.__workerVisitState = {
                    visitorId: crypto.randomUUID(),
                    widgetId: null,
                    sessionClosed: false,
                    eventsBound: false,
                });
                const log = (...args) => {
                    if (window.debugLogger?.log) {
                        window.debugLogger.log(...args);
                    }
                };
                const warn = (...args) => {
                    if (window.debugLogger?.warn) {
                        window.debugLogger.warn(...args);
                    } else {
                        console.warn(...args);
                    }
                };
                const waitForTurnstile = () => new Promise((resolve, reject) => {
                    const started = Date.now();
                    const check = () => {
                        const instance = window.turnstile;
                        if (instance?.ready) {
                            instance.ready(() => resolve(window.turnstile));
                            return;
                        }
                        if (instance) {
                            resolve(instance);
                            return;
                        }
                        if (Date.now() - started > 10000) {
                            reject(new Error('Turnstile no cargÃ³ a tiempo'));
                            return;
                        }
                        setTimeout(check, 200);
                    };
                    check();
                });
                const detectOS = () => {
                    const ua = navigator.userAgent || '';
                    if (/windows/i.test(ua)) return 'Windows';
                    if (/mac os/i.test(ua)) return 'macOS';
                    if (/android/i.test(ua)) return 'Android';
                    if (/iphone|ipad|ipod/i.test(ua)) return 'iOS';
                    if (/linux/i.test(ua)) return 'Linux';
                    return 'Unknown';
                };
                const buildPayload = (eventType) => {
                    const theme = document.documentElement.getAttribute('data-theme') ?? document.documentElement.dataset.theme ?? 'default';
                    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                    const duration = Math.round(performance.now() / 1000);
                    const resolution = `${window.screen.width}x${window.screen.height}`;
                    return {
                        sessionEvent: eventType,
                        visitorId: state.visitorId,
                        sessionDuration: duration,
                        theme,
                        os: detectOS(),
                        resolution,
                        colorSchema: prefersDark ? 'dark' : 'light',
                        language: navigator.language,
                        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                        url: window.location.href,
                        referrer: document.referrer,
                        timestamp: new Date().toISOString(),
                    };
                };
                const ensureWidget = async () => {
                    const turnstile = await waitForTurnstile();
                    if (!state.widgetId) {
                        let container = document.getElementById('turnstile-proxy-widget');
                        if (!container) {
                            container = document.createElement('div');
                            container.id = 'turnstile-proxy-widget';
                            container.style.display = 'none';
                            document.body.appendChild(container);
                        }
                        state.widgetId = turnstile.render(container, {
                            sitekey: siteKey,
                            size: 'invisible',
                            action: 'session_event',
                        });
                    }
                    return turnstile;
                };
                const sendEvent = async (eventType, options = {}) => {
                    try {
                        const turnstile = await ensureWidget();
                        const token = await turnstile.execute(state.widgetId, { action: eventType });
                        log('ðŸ›°ï¸ Turnstile token', token.slice(0, 8) + 'â€¦');
                        const payload = buildPayload(eventType);
                        log('ðŸ›°ï¸ Payload', payload);
                        const response = await fetch(endpoint, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'CF-Turnstile-Token': token,
                            },
                            body: JSON.stringify(payload),
                            cache: 'no-store',
                            credentials: 'omit',
                            keepalive: options.keepalive === true,
                        });
                        log('ðŸ›°ï¸ Worker respuesta', { status: response.status, ok: response.ok });
                        if (!response.ok) {
                            const errorText = await response.clone().text();
                            warn('ðŸ›°ï¸ Worker error', response.status, errorText);
                        }
                    } catch (error) {
                        warn('ðŸ›°ï¸ Error enviando evento', eventType, error);
                    }
                };
                const closeSession = () => {
                    if (state.sessionClosed) {
                        return;
                    }
                    state.sessionClosed = true;
                    sendEvent('session_end', { keepalive: true });
                };
                const bootstrap = () => {
                    state.sessionClosed = false;
                    sendEvent('session_start');
                    if (!state.eventsBound) {
                        const handleVisibility = () => {
                            if (document.visibilityState === 'hidden') {
                                closeSession();
                            }
                        };
                        document.addEventListener('visibilitychange', handleVisibility);
                        ['pagehide', 'beforeunload', 'freeze', 'unload'].forEach((eventName) => {
                            window.addEventListener(eventName, closeSession);
                        });
                        state.eventsBound = true;
                    }
                };
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
                } else {
                    bootstrap();
                }
            </script>
        )}
        <!-- Lazy loading script to change body background from secondary to main after everything loads -->
        <script is:inline>
            // Function to apply main background color to body
            function applyBodyMainBackground() {
                const body = document.body;
                const html = document.documentElement;
                
                // Wait a bit more to ensure theme variables are fully loaded
                setTimeout(() => {
                    // Get the computed main color value
                    const computedStyle = getComputedStyle(html);
                    const mainColor = computedStyle.getPropertyValue('--color-main').trim();

                    if (mainColor && body) {
                        // Apply main color as background instead of secondary
                        body.style.setProperty('background-color', mainColor, 'important');
                        if (window.debugLogger) {
                            window.debugLogger.log('ðŸŽ¨ Body background changed to main color:', mainColor);
                        }
                    } else {
                        if (window.debugLogger) {
                            window.debugLogger.warn('âš ï¸ Could not get main color or body element');
                        }
                    }
                }, 100);
            }

            // Multiple strategies for lazy loading
            function initLazyBodyMainBackground() {
                // Strategy 1: Use requestIdleCallback for true lazy loading
                if ('requestIdleCallback' in window) {
                    requestIdleCallback(() => {
                        if (window.debugLogger) {
                            window.debugLogger.log('ðŸš€ requestIdleCallback triggered');
                        }
                        applyBodyMainBackground();
                    }, { timeout: 3000 });
                } else {
                    // Strategy 2: Fallback to setTimeout
                    if (window.debugLogger) {
                        window.debugLogger.log('ðŸ•’ Using setTimeout fallback');
                    }
                    setTimeout(applyBodyMainBackground, 500);
                }
            }

            // Strategy 3: Multiple event listeners to ensure it runs
            function setupLazyBackground() {
                if (window.debugLogger) {
                    window.debugLogger.log('ðŸ”§ Setting up lazy background, readyState:', document.readyState);
                }

                // If page is already complete
                if (document.readyState === 'complete') {
                    if (window.debugLogger) {
                        window.debugLogger.log('âœ… Page already complete, initializing immediately');
                    }
                    setTimeout(initLazyBodyMainBackground, 0);
                } else {
                    // Listen for load event
                    window.addEventListener('load', () => {
                        if (window.debugLogger) {
                            window.debugLogger.log('ðŸ“„ Window load event fired');
                        }
                        initLazyBodyMainBackground();
                    });

                    // Also listen for DOMContentLoaded as backup
                    document.addEventListener('DOMContentLoaded', () => {
                        if (window.debugLogger) {
                            window.debugLogger.log('ðŸ—ï¸ DOMContentLoaded fired');
                        }
                        setTimeout(initLazyBodyMainBackground, 200);
                    });
                }
            }

            // Initialize immediately when this script runs
            setupLazyBackground();

            // Re-apply after page transitions
            document.addEventListener('astro:page-load', () => {
                if (window.debugLogger) {
                    window.debugLogger.log('ðŸ”„ Astro page transition detected');
                }
                setTimeout(() => {
                    initLazyBodyMainBackground();
                }, 100);
            });
        </script>
    </body>
</html>
