---
import { cn } from '@/lib/utils';
import { debugLogger } from '@/utils/debug-logger';

export interface Props {
  href?: string;
  variant?: 'normal' | 'outline';
  size?: 'normal' | 'sm';
  filled?: boolean;
  elevated?: boolean;
  class?: string;
  style?: string;
  onClick?: string;
  type?: 'button' | 'submit' | 'reset';
  disabled?: boolean;
  id?: string;
  [key: string]: unknown;
}

const {
  href,
  variant = 'normal',
  size = 'normal',
  filled = false,
  elevated = false,
  class: className,
  style,
  onClick,
  type = 'button',
  disabled = false,
  id,
  ...rest
} = Astro.props as Props;


const Tag = href ? 'a' : 'button';


const buttonClasses = cn(
  'font-bold uppercase tracking-wide cursor-pointer border-double border-2 whitespace-nowrap flex items-center justify-center no-underline w-fit h-fit',
  {
    // Size variants
    'px-6 text-sm h-12': size === 'normal',
    'px-2 h-8 font-grotesk font-bold': size === 'sm',
    // Position and elevation - usando solo Tailwind
    'relative z-20': !elevated && variant !== 'outline',
    'relative z-30': elevated && variant !== 'outline',
    'relative z-30 active:top-0 active:left-0': variant === 'outline' && !elevated,
    'relative z-30 border-secondary overflow-hidden': variant === 'outline' && elevated,
    // Colors and states
    'bg-main text-secondary border-main shadow-[inset_0_0_0_2px_var(--color-secondary)]': filled,
    'bg-secondary text-main border-main shadow-[inset_0_0_0_2px_var(--color-secondary)] hover:bg-main hover:text-secondary': !filled && variant !== 'outline',
    'bg-secondary text-main border-transparent overflow-hidden group': variant === 'outline',
  },
  className
);

// Shadow fills the exact label container area via inset-0
const shadowClasses = cn(
  'absolute inset-0 border-2 pointer-events-none font-bold uppercase tracking-wide flex items-center justify-center diagonal-stripe',
  'bg-secondary bg-opacity-60 z-10'
);
---

{elevated && variant !== 'outline' ? (
  <!-- Elevated button con sombra usando solo Tailwind -->
  <div class="relative inline-block w-fit group">
    <!-- Shadow fija -->
    <div class={cn(shadowClasses, 'top-0 left-0')} aria-hidden="true"></div>
    <!-- Button que se mueve -->
    <div class="elevated-normal-button-wrapper relative z-20">
      <Tag
        class={cn(buttonClasses, {
          'button-with-sound': elevated
        })}
        href={href}
        style={size === 'sm' ? `font-size: 14px; ${style || ''}` : style}
        onclick={onClick}
        type={type}
        disabled={disabled}
        id={id}
        {...rest}
      >
        <slot />
      </Tag>
    </div>
  </div>
) : variant === 'outline' && elevated ? (
  <div class="relative w-fit h-fit group">
    <!-- Fixed shadow at base position filling label container -->
    <div class="absolute inset-0 z-10">
      <div class={shadowClasses} aria-hidden="true"></div>
    </div>
    <!-- Movable button -->
    <div class="outline-elevated-button relative z-20">
      <Tag class={cn(buttonClasses, 'group outline-animated-button', { 'button-with-sound': elevated })} href={href} style={size === 'sm' ? `font-size: 14px; ${style || ''}` : style} onclick={onClick} type={type} disabled={disabled} id={id} {...rest}>
        <slot />
      </Tag>
    </div>
  </div>
) : (
  <Tag class={cn(buttonClasses, { 'button-with-sound': elevated })} href={href} style={size === 'sm' ? `font-size: 14px; ${style || ''}` : style} onclick={onClick} type={type} disabled={disabled} id={id} {...rest}>
    {variant === 'outline' && (
      <>
        <div class="absolute top-0 left-0 w-full h-0 border-t-2 border-double border-main transform -translate-x-full group-hover:translate-x-0 group-hover:delay-0 transition-transform duration-200 ease-[cubic-bezier(0.25,0.46,0.45,0.94)] delay-600"></div>
        <div class="absolute top-0 right-0 w-0 h-full border-r-2 border-double border-main transform -translate-y-full group-hover:translate-y-0 group-hover:delay-200 transition-transform duration-200 ease-[cubic-bezier(0.25,0.46,0.45,0.94)] delay-400"></div>
        <div class="absolute bottom-0 right-0 w-full h-0 border-b-2 border-double border-main transform translate-x-full group-hover:translate-x-0 group-hover:delay-400 transition-transform duration-200 ease-[cubic-bezier(0.25,0.46,0.45,0.94)] delay-200"></div>
        <div class="absolute bottom-0 left-0 w-0 h-full border-l-2 border-double border-main transform translate-y-full group-hover:translate-y-0 group-hover:delay-600 transition-transform duration-200 ease-[cubic-bezier(0.25,0.46,0.45,0.94)] delay-0"></div>
      </>
    )}
    <slot />
  </Tag>
)}

<script>
  // Debug helper - only logs when debug mode is enabled
  const isDebug = () => {
    if (typeof window !== 'undefined') {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('debug') === 'true' || localStorage.getItem('debug') === 'true';
    }
    return false;
  };
  const log = (...args) => isDebug() && console.log(...args);
  const warn = (...args) => isDebug() && console.warn(...args);

  log('🚀 Button script loaded');

  function initializeButtons() {
    log('🔧 Initializing buttons...');

    // Create audio element for button click sound
    const clickAudio = new Audio('/buttonPress.wav');
    clickAudio.volume = 0.3;
    clickAudio.preload = 'auto';

    // Play click sound
    function playClickSound() {
      try {
        clickAudio.currentTime = 0; // Reset to start
        clickAudio.play().catch(() => {
          // Silently handle autoplay restrictions
        });
      } catch (error) {
        // Silently handle any audio errors
      }
    }

    // Add click sound to all buttons
    const buttons = document.querySelectorAll('.button-with-sound');
    log('🔊 Buttons with sound found:', buttons.length);
    buttons.forEach(button => {
      button.addEventListener('click', () => {
        playClickSound();
      });
    });

    // Handle outline elevated animation
    const outlineElevatedButtons = document.querySelectorAll('.outline-elevated-button');
    log('🔍 Outline elevated buttons found:', outlineElevatedButtons.length);

    if (outlineElevatedButtons.length === 0) {
      warn('⚠️ No outline elevated buttons found in DOM');
    }

    outlineElevatedButtons.forEach((buttonWrapper) => {
      const actualButton = buttonWrapper.querySelector('button, a');
      log('🎯 Setting up outline elevated button:', actualButton);
    
      
      let showTimeouts: number[] = [];
      let isAnimating = false;
      let isLocked = false;
      let isCurrentlyHovering = false;
      let hoverTimeout: number | null = null;
      
      if (actualButton) {
        // Create border elements dynamically
        const borderTop = document.createElement('div');
        borderTop.className = 'absolute top-0 left-0 w-full h-0 border-t-2 border-double border-main';
        borderTop.style.transform = 'translateX(-105%)';
        
        const borderRight = document.createElement('div');
        borderRight.className = 'absolute top-0 right-0 w-0 h-full border-r-2 border-double border-main';
        borderRight.style.transform = 'translateY(-105%)';
        
        const borderBottom = document.createElement('div');
        borderBottom.className = 'absolute bottom-0 right-0 w-full h-0 border-b-2 border-double border-main';
        borderBottom.style.transform = 'translateX(105%)';
        
        const borderLeft = document.createElement('div');
        borderLeft.className = 'absolute bottom-0 left-0 w-0 h-full border-l-2 border-double border-main';
        borderLeft.style.transform = 'translateY(105%)';
        
        // Add borders to button
        actualButton.appendChild(borderTop);
        actualButton.appendChild(borderRight);
        actualButton.appendChild(borderBottom);
        actualButton.appendChild(borderLeft);

         

        // Function to show borders sequentially
        function showBordersSequential() { 

          // Don't start if already animating or locked
          if (isAnimating || isLocked) {
          
            return;
          }
          
          isAnimating = true;
          
          // Clear any existing show timeouts
          showTimeouts.forEach(timeout => clearTimeout(timeout));
          showTimeouts = [];
          
          // Reset all borders to hidden state first
          borderTop.style.transition = 'none';
          borderRight.style.transition = 'none';
          borderBottom.style.transition = 'none';
          borderLeft.style.transition = 'none';
          
          borderTop.style.transform = 'translateX(-100%)';
          borderRight.style.transform = 'translateY(-100%)';
          borderBottom.style.transform = 'translateX(100%)';
          borderLeft.style.transform = 'translateY(100%)';
          
          // Force reflow
          borderTop.offsetHeight;
          
          // Top border first
          const timeout1 = window.setTimeout(() => {
            if (borderTop) {
              borderTop.style.transition = 'transform 250ms ease-out';
              borderTop.style.transform = 'translateX(0)';
            }
          }, 30);
          showTimeouts.push(timeout1);
          
          // Right border after top completes
          const timeout2 = window.setTimeout(() => {
            if (borderRight) {
              borderRight.style.transition = 'transform 250ms ease-out';
              borderRight.style.transform = 'translateY(0)';
            }
          }, 280);
          showTimeouts.push(timeout2);
          
          // Bottom border after right completes  
          const timeout3 = window.setTimeout(() => {
            if (borderBottom) {
              borderBottom.style.transition = 'transform 250ms ease-out';
              borderBottom.style.transform = 'translateX(0)';
            }
          }, 530);
          showTimeouts.push(timeout3);
          
          // Left border after bottom completes
          const timeout4 = window.setTimeout(() => {
            if (borderLeft) {
              borderLeft.style.transition = 'transform 250ms ease-out';
              borderLeft.style.transform = 'translateY(0)';
            }
          }, 780);
          showTimeouts.push(timeout4);
          
          // Mark animation as complete and lock the button
          const timeout5 = window.setTimeout(() => {
            isAnimating = false;
            isLocked = true;
            
            // Hide dynamic borders
            if (borderTop) borderTop.style.display = 'none';
            if (borderRight) borderRight.style.display = 'none';
            if (borderBottom) borderBottom.style.display = 'none';
            if (borderLeft) borderLeft.style.display = 'none';
            
            // Add border-double to the button itself
            if (actualButton) {
              actualButton.classList.remove('border-transparent', 'border-0');
              actualButton.classList.add('border-double', 'border-2', 'border-main');
              (actualButton as HTMLElement).style.boxSizing = 'border-box';
              // Force border via inline styles to ensure visibility
              (actualButton as HTMLElement).style.border = '2px double var(--color-main)';
        
            }

            // If mouse is still hovering when animation completes, activate hover
            if (actualButton && isCurrentlyHovering) {
              actualButton.classList.remove('bg-secondary', 'text-main', 'border-transparent');
              actualButton.classList.add('bg-main', 'text-secondary', 'border-double', 'border-main', 'shadow-[inset_0_0_0_2px_var(--color-secondary)]');
         
            }

      
          }, 1030); // After last border completes (780ms + 250ms)
          showTimeouts.push(timeout5);
        }
        
        

        // Function to handle animation trigger (both hover and focus)
        const triggerAnimation = () => {
        
          
          // Clear any existing hover timeout
          if (hoverTimeout) {
            clearTimeout(hoverTimeout);
          }
          
          if (isLocked) {
            // Button is locked - apply hover styles and shrinking effect like elevated buttons
            actualButton.classList.remove('bg-secondary', 'text-main', 'border-transparent');
            actualButton.classList.add('bg-main', 'text-secondary', 'border-double', 'border-main', 'shadow-[inset_0_0_0_2px_var(--color-secondary)]');
            
            // Add shrinking effect like elevated buttons (30% less elevation)
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(-8.4px, -8.4px)';
            htmlButtonWrapper.style.transition = 'transform 150ms ease-out';

  
            return;
          }
          
          // Start animation sequence
          showBordersSequential();
          
          // Elevate after sequence completes - always happens regardless of hover state
          setTimeout(() => {
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(-12px, -12px)';
            htmlButtonWrapper.style.transition = 'transform 200ms ease-out';
           
          }, 1030);
        };

        actualButton.addEventListener('mouseenter', () => triggerAnimation());
        actualButton.addEventListener('focus', () => triggerAnimation());
        
        // Handle focus for locked buttons (same as hover)
        actualButton.addEventListener('focus', () => {
          if (isLocked) {
            actualButton.classList.remove('bg-secondary', 'text-main', 'border-transparent');
            actualButton.classList.add('bg-main', 'text-secondary', 'border-double', 'border-main', 'shadow-[inset_0_0_0_2px_var(--color-secondary)]');
            
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(-8.4px, -8.4px)';
            htmlButtonWrapper.style.transition = 'transform 150ms ease-out';

           
          }
        });
        
        // Handle blur for locked buttons (same as mouse leave)
        actualButton.addEventListener('blur', () => {
          if (isLocked) {
            actualButton.classList.remove('bg-main', 'text-secondary', 'border-double', 'border-main', 'shadow-[inset_0_0_0_2px_var(--color-secondary)]');
            actualButton.classList.add('bg-secondary', 'text-main', 'border-transparent');
            
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(-12px, -12px)';
            htmlButtonWrapper.style.transition = 'transform 150ms ease-out';

        
          }
        });

        actualButton.addEventListener('mouseleave', () => {
   
          
          // Clear hover timeout and reset state
          if (hoverTimeout) {
            clearTimeout(hoverTimeout);
            hoverTimeout = null;
          }
          isCurrentlyHovering = false;
          
          if (isLocked) {
            // Remove hover styles from locked button and restore full elevation
            actualButton.classList.remove('bg-main', 'text-secondary', 'border-double', 'border-main', 'shadow-[inset_0_0_0_2px_var(--color-secondary)]');
            actualButton.classList.add('bg-secondary', 'text-main', 'border-transparent');
            
            // Restore full elevation like elevated buttons
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(-12px, -12px)';
            htmlButtonWrapper.style.transition = 'transform 150ms ease-out';
 
            return;
          }

         
        });
        
        actualButton.addEventListener('mousedown', () => {
          if (isLocked) {
            // Quick down animation like other elevated buttons - no transition for instant effect
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(0px, 0px)';
            htmlButtonWrapper.style.transition = 'none';
          }
        });
        
        actualButton.addEventListener('mouseup', () => {
          if (isLocked) {
            // Return to elevated position - no transition for instant effect  
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(-12px, -12px)';
            htmlButtonWrapper.style.transition = 'none';
          }
        });
      }
    });

    // Handle normal elevated button - same as outline elevated
    const normalElevatedButtonWrappers = document.querySelectorAll('.elevated-normal-button-wrapper');
    log('🔍 Normal elevated button wrappers found:', normalElevatedButtonWrappers.length);

    normalElevatedButtonWrappers.forEach((buttonWrapper) => {
      const htmlButtonWrapper = buttonWrapper as HTMLElement;
      const actualButton = buttonWrapper.querySelector('button, a');
      let hasElevated = false;

      // Elevate after 1 second on page load
      setTimeout(() => {
        if (!hasElevated && htmlButtonWrapper.style) {
          htmlButtonWrapper.style.transform = 'translate(-12px, -12px)';
          htmlButtonWrapper.style.transition = 'transform 200ms ease-out';
          hasElevated = true;
        }
      }, 1000);

      // Handle hover for elevated buttons (30% less elevation) - SMOOTH
      if (actualButton) {
        actualButton.addEventListener('mouseenter', () => {
          if (hasElevated && htmlButtonWrapper.style) {
            htmlButtonWrapper.style.transform = 'translate(-8.4px, -8.4px)';
            htmlButtonWrapper.style.transition = 'transform 150ms ease-out';
          }
        });

        actualButton.addEventListener('mouseleave', () => {
          if (hasElevated && htmlButtonWrapper.style) {
            htmlButtonWrapper.style.transform = 'translate(-12px, -12px)';
            htmlButtonWrapper.style.transition = 'transform 150ms ease-out';
          }
        });

        actualButton.addEventListener('focus', () => {
          if (hasElevated && htmlButtonWrapper.style) {
            htmlButtonWrapper.style.transform = 'translate(-8.4px, -8.4px)';
            htmlButtonWrapper.style.transition = 'transform 150ms ease-out';
          }
        });

        actualButton.addEventListener('blur', () => {
          if (hasElevated && htmlButtonWrapper.style) {
            htmlButtonWrapper.style.transform = 'translate(-12px, -12px)';
            htmlButtonWrapper.style.transition = 'transform 150ms ease-out';
          }
        });

        // Handle press animation when elevated
        actualButton.addEventListener('mousedown', () => {
          if (hasElevated && htmlButtonWrapper.style) {
            htmlButtonWrapper.style.transform = 'translate(0px, 0px)';
            htmlButtonWrapper.style.transition = 'none';
          }
        });

        actualButton.addEventListener('mouseup', () => {
          if (hasElevated && htmlButtonWrapper.style) {
            const targetTransform = actualButton.matches(':hover') ? 'translate(-8.4px, -8.4px)' : 'translate(-12px, -12px)';
            htmlButtonWrapper.style.transform = targetTransform;
            htmlButtonWrapper.style.transition = 'none';
          }
        });
      }
    });

    log('✅ Button initialization complete');
  }

  // Run on initial load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeButtons);
  } else {
    initializeButtons();
  }

  // Run on Astro page transitions
  document.addEventListener('astro:page-load', initializeButtons);
</script>
