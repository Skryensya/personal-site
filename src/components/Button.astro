---
import { cn } from '@/lib/utils';

export interface Props {
  href?: string;
  variant?: 'normal' | 'outline';
  size?: 'normal' | 'sm';
  filled?: boolean;
  elevated?: boolean;
  class?: string;
  style?: string;
  onClick?: string;
  type?: 'button' | 'submit' | 'reset';
  disabled?: boolean;
  id?: string;
}

const {
  href,
  variant = 'normal',
  size = 'normal',
  filled = false,
  elevated = false,
  class: className,
  style,
  onClick,
  type = 'button',
  disabled = false,
  id,
} = Astro.props;


const Tag = href ? 'a' : 'button';


const buttonClasses = cn(
  'font-bold uppercase tracking-wide cursor-pointer border-double border-2 whitespace-nowrap flex items-center justify-center no-underline',
  {
    // Size variants
    'px-6 text-sm h-12': size === 'normal',
    'px-2 h-8 font-grotesk font-bold': size === 'sm',
    // Position and elevation
    'relative top-0 left-0 z-20': !elevated && variant !== 'outline',
    'absolute top-0 left-0 z-30 elevated-button': elevated && variant !== 'outline',
    'relative top-0 left-0 z-30 active:top-0 active:left-0': variant === 'outline' && !elevated,
    'relative top-0 left-0 z-30 border-secondary': variant === 'outline' && elevated,
    // Colors and states
    'bg-main text-secondary border-main shadow-[inset_0_0_0_2px_var(--color-secondary)]': filled,
    'bg-secondary text-main border-main shadow-[inset_0_0_0_2px_var(--color-secondary)] hover:bg-main hover:text-secondary': !filled && variant !== 'outline',
    'bg-secondary text-main border-transparent overflow-hidden group': variant === 'outline',
  },
  className
);

const shadowClasses = cn(
  'absolute top-0 left-0 border-2 whitespace-nowrap pointer-events-none font-bold uppercase tracking-wide flex items-center justify-center diagonal-stripe',
  'bg-secondary bg-opacity-60 z-10',
  {
    // Size variants for shadow
    'px-6 text-sm h-12': size === 'normal',
    'px-2 h-8 font-grotesk font-bold': size === 'sm',
  }
);
---

<div class={cn('relative inline-block w-fit', { 
  'isolate z-30': elevated,
  'z-20': !elevated 
})}>
  {variant === 'outline' && elevated ? (
    <div class="relative w-fit h-fit">
      <!-- Fixed shadow at base position -->
      <div class="absolute top-0 left-0 z-10">
        <div
          class={shadowClasses}
          
        >
          <span class="invisible">
            <slot />
          </span>
        </div>
      </div>
      <!-- Movable button -->
      <div class="outline-elevated-button relative z-20">
        <Tag class={cn(buttonClasses, 'group outline-animated-button', { 'button-with-sound': elevated })} href={href} style={size === 'sm' ? `font-size: 14px; ${style || ''}` : style} onclick={onClick} type={type} disabled={disabled} id={id}>
          <slot />
        </Tag>
      </div>
    </div>
  ) : (
    <Tag class={cn(buttonClasses, { 'button-with-sound': elevated })} href={href} style={size === 'sm' ? `font-size: 14px; ${style || ''}` : style} onclick={onClick} type={type} disabled={disabled} id={id}>
      {variant === 'outline' && (
        <>
          <div class="absolute top-0 left-0 w-full h-0 border-t-2 border-double border-main transform -translate-x-full group-hover:translate-x-0 group-hover:delay-0 transition-transform duration-200 ease-[cubic-bezier(0.25,0.46,0.45,0.94)] delay-600"></div>
          <div class="absolute top-0 right-0 w-0 h-full border-r-2 border-double border-main transform -translate-y-full group-hover:translate-y-0 group-hover:delay-200 transition-transform duration-200 ease-[cubic-bezier(0.25,0.46,0.45,0.94)] delay-400"></div>
          <div class="absolute bottom-0 right-0 w-full h-0 border-b-2 border-double border-main transform translate-x-full group-hover:translate-x-0 group-hover:delay-400 transition-transform duration-200 ease-[cubic-bezier(0.25,0.46,0.45,0.94)] delay-200"></div>
          <div class="absolute bottom-0 left-0 w-0 h-full border-l-2 border-double border-main transform translate-y-full group-hover:translate-y-0 group-hover:delay-600 transition-transform duration-200 ease-[cubic-bezier(0.25,0.46,0.45,0.94)] delay-0"></div>
        </>
      )}
      <slot />
    </Tag>
  )}

  {elevated && variant !== 'outline' && (
    <div
      class={shadowClasses}
      aria-hidden="true"
    >
      <span class="invisible">
        <slot />
      </span>
    </div>
  )}
</div>

<script>
  document.addEventListener('astro:page-load', () => {
    // Create audio element for button click sound
    const clickAudio = new Audio('/buttonPress.wav');
    clickAudio.volume = 0.3;
    clickAudio.preload = 'auto';
    
    // Play click sound
    function playClickSound() {
      try {
        clickAudio.currentTime = 0; // Reset to start
        clickAudio.play().catch(() => {
          // Silently handle autoplay restrictions
        });
      } catch (error) {
        // Silently handle any audio errors
      }
    }
    
    // Add click sound to all buttons
    const buttons = document.querySelectorAll('.button-with-sound');
    buttons.forEach(button => {
      button.addEventListener('click', () => {
        playClickSound();
      });
    });

    // Handle outline elevated animation
    const outlineElevatedButtons = document.querySelectorAll('.outline-elevated-button');
  

    outlineElevatedButtons.forEach((buttonWrapper, index) => {
      const actualButton = buttonWrapper.querySelector('button, a');
    
      
      let showTimeouts: number[] = [];
      let isAnimating = false;
      let isLocked = false;
      let isCurrentlyHovering = false;
      let hoverTimeout: number | null = null;
      
      if (actualButton) {
        // Create border elements dynamically
        const borderTop = document.createElement('div');
        borderTop.className = 'absolute top-0 left-0 w-full h-0 border-t-2 border-double border-main';
        borderTop.style.transform = 'translateX(-105%)';
        
        const borderRight = document.createElement('div');
        borderRight.className = 'absolute top-0 right-0 w-0 h-full border-r-2 border-double border-main';
        borderRight.style.transform = 'translateY(-105%)';
        
        const borderBottom = document.createElement('div');
        borderBottom.className = 'absolute bottom-0 right-0 w-full h-0 border-b-2 border-double border-main';
        borderBottom.style.transform = 'translateX(105%)';
        
        const borderLeft = document.createElement('div');
        borderLeft.className = 'absolute bottom-0 left-0 w-0 h-full border-l-2 border-double border-main';
        borderLeft.style.transform = 'translateY(105%)';
        
        // Add borders to button
        actualButton.appendChild(borderTop);
        actualButton.appendChild(borderRight);
        actualButton.appendChild(borderBottom);
        actualButton.appendChild(borderLeft);

         

        // Function to show borders sequentially
        function showBordersSequential() { 

          // Don't start if already animating or locked
          if (isAnimating || isLocked) {
          
            return;
          }
          
          isAnimating = true;
          
          // Clear any existing show timeouts
          showTimeouts.forEach(timeout => clearTimeout(timeout));
          showTimeouts = [];
          
          // Reset all borders to hidden state first
          borderTop.style.transition = 'none';
          borderRight.style.transition = 'none';
          borderBottom.style.transition = 'none';
          borderLeft.style.transition = 'none';
          
          borderTop.style.transform = 'translateX(-100%)';
          borderRight.style.transform = 'translateY(-100%)';
          borderBottom.style.transform = 'translateX(100%)';
          borderLeft.style.transform = 'translateY(100%)';
          
          // Force reflow
          borderTop.offsetHeight;
          
          // Top border first
          const timeout1 = window.setTimeout(() => {
            if (borderTop) {
              borderTop.style.transition = 'transform 250ms ease-out';
              borderTop.style.transform = 'translateX(0)';
            }
          }, 30);
          showTimeouts.push(timeout1);
          
          // Right border after top completes
          const timeout2 = window.setTimeout(() => {
            if (borderRight) {
              borderRight.style.transition = 'transform 250ms ease-out';
              borderRight.style.transform = 'translateY(0)';
            }
          }, 280);
          showTimeouts.push(timeout2);
          
          // Bottom border after right completes  
          const timeout3 = window.setTimeout(() => {
            if (borderBottom) {
              borderBottom.style.transition = 'transform 250ms ease-out';
              borderBottom.style.transform = 'translateX(0)';
            }
          }, 530);
          showTimeouts.push(timeout3);
          
          // Left border after bottom completes
          const timeout4 = window.setTimeout(() => {
            if (borderLeft) {
              borderLeft.style.transition = 'transform 250ms ease-out';
              borderLeft.style.transform = 'translateY(0)';
            }
          }, 780);
          showTimeouts.push(timeout4);
          
          // Mark animation as complete and lock the button
          const timeout5 = window.setTimeout(() => {
            isAnimating = false;
            isLocked = true;
            
            // Hide dynamic borders
            if (borderTop) borderTop.style.display = 'none';
            if (borderRight) borderRight.style.display = 'none';
            if (borderBottom) borderBottom.style.display = 'none';
            if (borderLeft) borderLeft.style.display = 'none';
            
            // Add border-double to the button itself
            if (actualButton) {
              actualButton.classList.remove('border-transparent', 'border-0');
              actualButton.classList.add('border-double', 'border-2', 'border-main');
              (actualButton as HTMLElement).style.boxSizing = 'border-box';
              // Force border via inline styles to ensure visibility
              (actualButton as HTMLElement).style.border = '2px double var(--color-main)';
        
            }

            // If mouse is still hovering when animation completes, activate hover
            if (actualButton && isCurrentlyHovering) {
              actualButton.classList.remove('bg-secondary', 'text-main', 'border-transparent');
              actualButton.classList.add('bg-main', 'text-secondary', 'border-double', 'border-main', 'shadow-[inset_0_0_0_2px_var(--color-secondary)]');
         
            }

      
          }, 1030); // After last border completes (780ms + 250ms)
          showTimeouts.push(timeout5);
        }
        
        

        // Function to handle animation trigger (both hover and focus)
        const triggerAnimation = (eventType: string) => {
        
          
          // Clear any existing hover timeout
          if (hoverTimeout) {
            clearTimeout(hoverTimeout);
          }
          
          if (isLocked) {
            // Button is locked - apply hover styles and shrinking effect like elevated buttons
            actualButton.classList.remove('bg-secondary', 'text-main', 'border-transparent');
            actualButton.classList.add('bg-main', 'text-secondary', 'border-double', 'border-main', 'shadow-[inset_0_0_0_2px_var(--color-secondary)]');
            
            // Add shrinking effect like elevated buttons (30% less elevation)
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(-8.4px, -8.4px)';
            htmlButtonWrapper.style.transition = 'transform 150ms ease-out';

  
            return;
          }
          
          // Start animation sequence
          showBordersSequential();
          
          // Elevate after sequence completes - always happens regardless of hover state
          setTimeout(() => {
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(-12px, -12px)';
            htmlButtonWrapper.style.transition = 'transform 200ms ease-out';
           
          }, 1030);
        };

        actualButton.addEventListener('mouseenter', () => triggerAnimation('Mouse enter'));
        actualButton.addEventListener('focus', () => triggerAnimation('Focus'));
        
        // Handle focus for locked buttons (same as hover)
        actualButton.addEventListener('focus', () => {
          if (isLocked) {
            actualButton.classList.remove('bg-secondary', 'text-main', 'border-transparent');
            actualButton.classList.add('bg-main', 'text-secondary', 'border-double', 'border-main', 'shadow-[inset_0_0_0_2px_var(--color-secondary)]');
            
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(-8.4px, -8.4px)';
            htmlButtonWrapper.style.transition = 'transform 150ms ease-out';

           
          }
        });
        
        // Handle blur for locked buttons (same as mouse leave)
        actualButton.addEventListener('blur', () => {
          if (isLocked) {
            actualButton.classList.remove('bg-main', 'text-secondary', 'border-double', 'border-main', 'shadow-[inset_0_0_0_2px_var(--color-secondary)]');
            actualButton.classList.add('bg-secondary', 'text-main', 'border-transparent');
            
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(-12px, -12px)';
            htmlButtonWrapper.style.transition = 'transform 150ms ease-out';

        
          }
        });

        actualButton.addEventListener('mouseleave', () => {
   
          
          // Clear hover timeout and reset state
          if (hoverTimeout) {
            clearTimeout(hoverTimeout);
            hoverTimeout = null;
          }
          isCurrentlyHovering = false;
          
          if (isLocked) {
            // Remove hover styles from locked button and restore full elevation
            actualButton.classList.remove('bg-main', 'text-secondary', 'border-double', 'border-main', 'shadow-[inset_0_0_0_2px_var(--color-secondary)]');
            actualButton.classList.add('bg-secondary', 'text-main', 'border-transparent');
            
            // Restore full elevation like elevated buttons
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(-12px, -12px)';
            htmlButtonWrapper.style.transition = 'transform 150ms ease-out';
 
            return;
          }

         
        });
        
        actualButton.addEventListener('mousedown', () => {
          if (isLocked) {
            // Quick down animation like other elevated buttons - no transition for instant effect
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(0px, 0px)';
            htmlButtonWrapper.style.transition = 'none';
          }
        });
        
        actualButton.addEventListener('mouseup', () => {
          if (isLocked) {
            // Return to elevated position - no transition for instant effect  
            const htmlButtonWrapper = buttonWrapper as HTMLElement;
            htmlButtonWrapper.style.transform = 'translate(-12px, -12px)';
            htmlButtonWrapper.style.transition = 'none';
          }
        });
      }
    });

    // Handle regular elevated button animation (start pressed, then elevate after 1 second)
    const elevatedButtons = document.querySelectorAll('.elevated-button');
    
    elevatedButtons.forEach((button) => {
      const htmlButton = button as HTMLElement;
      let hasElevated = false;
      const isFilled = htmlButton.classList.contains('bg-main');
      
      // Elevate after 1 second on page load
      setTimeout(() => {
        if (!hasElevated && htmlButton.style) {
          htmlButton.style.transform = 'translate(-12px, -12px)';
          htmlButton.style.transition = 'transform 200ms ease-out';
          hasElevated = true;
        }
      }, 1000);
      
      // Handle hover for filled buttons (30% less elevation)
      if (isFilled) {
        htmlButton.addEventListener('mouseenter', () => {
          if (hasElevated && htmlButton.style) {
            htmlButton.style.transform = 'translate(-8.4px, -8.4px)';
            htmlButton.style.transition = 'transform 150ms ease-out';
          }
        });
        
        htmlButton.addEventListener('mouseleave', () => {
          if (hasElevated && htmlButton.style) {
            htmlButton.style.transform = 'translate(-12px, -12px)';
            htmlButton.style.transition = 'transform 150ms ease-out';
          }
        });
        
        htmlButton.addEventListener('focus', () => {
          if (hasElevated && htmlButton.style) {
            htmlButton.style.transform = 'translate(-8.4px, -8.4px)';
            htmlButton.style.transition = 'transform 150ms ease-out';
          }
        });
        
        htmlButton.addEventListener('blur', () => {
          if (hasElevated && htmlButton.style) {
            htmlButton.style.transform = 'translate(-12px, -12px)';
            htmlButton.style.transition = 'transform 150ms ease-out';
          }
        });
      }
      
      // Handle press animation when elevated
      htmlButton.addEventListener('mousedown', () => {
        if (hasElevated && htmlButton.style) {
          htmlButton.style.transform = 'translate(0px, 0px)';
          htmlButton.style.transition = 'none';
        }
      });
      
      htmlButton.addEventListener('mouseup', () => {
        if (hasElevated && htmlButton.style) {
          const targetTransform = isFilled && htmlButton.matches(':hover') ? 'translate(-8.4px, -8.4px)' : 'translate(-12px, -12px)';
          htmlButton.style.transform = targetTransform;
          htmlButton.style.transition = 'none';
        }
      });
    });
  });
</script>

