---
export interface Props {
  id: string;
  className?: string;
  dropdownClassName?: string;
}

const { id, className = '', dropdownClassName = '' } = Astro.props;
---

<div class={`relative dropdown-container ${className}`} data-dropdown-id={id}>
  <!-- Trigger Button -->
  <button 
    class="dropdown-trigger w-7 h-7 md:w-auto md:h-8 border border-main bg-secondary flex items-center justify-center hover:bg-main group md:px-2 md:gap-2"
    aria-haspopup="true"
    aria-expanded="false"
    data-dropdown-trigger={id}
  >
    <slot name="trigger" />
  </button>
  
  <!-- Dropdown Content -->
  <div 
    class={`dropdown-content absolute bg-secondary border border-main opacity-0 invisible transform scale-95 transition-all duration-200 z-[999] rounded-none ${dropdownClassName}`}
    role="menu"
    data-dropdown-content={id}
  >
    <slot />
  </div>
</div>

<style>
  .dropdown-container {
    position: relative;
  }
  
  .dropdown-content {
    backdrop-filter: blur(8px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    min-width: 120px;
    max-width: 250px;
    max-height: 300px;
    overflow-y: auto;
    overflow-x: hidden;
    white-space: nowrap;
    position: fixed; /* Use fixed positioning for Floating UI */
    top: 0;
    left: 0;
  }
  
  .dropdown-container.open .dropdown-content {
    opacity: 1;
    visibility: visible;
    transform: scale(1);
  }
  
  .dropdown-option:focus {
    outline: 2px solid var(--color-main);
    outline-offset: -2px;
    background: var(--color-main) !important;
    color: var(--color-secondary) !important;
  }
  
  /* Ensure dropdowns don't cause page overflow */
  .dropdown-content {
    box-sizing: border-box;
  }
</style>

<script>
  import { computePosition, flip, shift, offset } from '@floating-ui/dom';

  // Dropdown manager with Floating UI
  class DropdownManager {
    private static instance: DropdownManager;
    private openDropdown: string | null = null;

    static getInstance(): DropdownManager {
      if (!DropdownManager.instance) {
        DropdownManager.instance = new DropdownManager();
      }
      return DropdownManager.instance;
    }

    async openDropdownById(dropdownId: string) {
      // Close any currently open dropdown
      if (this.openDropdown && this.openDropdown !== dropdownId) {
        this.closeDropdownById(this.openDropdown);
      }

      const container = document.querySelector(`[data-dropdown-id="${dropdownId}"]`);
      const trigger = container?.querySelector(`[data-dropdown-trigger="${dropdownId}"]`) as HTMLElement;
      const content = container?.querySelector(`[data-dropdown-content="${dropdownId}"]`) as HTMLElement;

      if (!trigger || !container || !content) return;

      // Update aria-expanded
      trigger.setAttribute('aria-expanded', 'true');
      
      // Position dropdown using Floating UI
      const { x, y } = await computePosition(trigger, content, {
        placement: 'bottom-start', // This positions dropdown below and to the left (start)
        middleware: [
          offset(4), // 4px gap from trigger
          flip(), // Flip to top if no space below
          shift({ padding: 8 }) // Shift away from viewport edges
        ],
      });

      // Apply positioning
      Object.assign(content.style, {
        left: `${x}px`,
        top: `${y}px`,
      });
      
      // Show dropdown
      container.classList.add('open');
      this.openDropdown = dropdownId;
    }

    closeDropdownById(dropdownId: string) {
      const container = document.querySelector(`[data-dropdown-id="${dropdownId}"]`);
      const trigger = container?.querySelector(`[data-dropdown-trigger="${dropdownId}"]`) as HTMLElement;

      if (!trigger || !container) return;

      // Update aria-expanded
      trigger.setAttribute('aria-expanded', 'false');
      
      // Hide dropdown
      container.classList.remove('open');

      if (this.openDropdown === dropdownId) {
        this.openDropdown = null;
      }
    }

    toggleDropdown(dropdownId: string) {
      const container = document.querySelector(`[data-dropdown-id="${dropdownId}"]`);
      if (container?.classList.contains('open')) {
        this.closeDropdownById(dropdownId);
      } else {
        this.openDropdownById(dropdownId);
      }
    }

    closeAll() {
      if (this.openDropdown) {
        this.closeDropdownById(this.openDropdown);
      }
    }
  }

  // Initialize on page load
  document.addEventListener('astro:page-load', () => {
    const manager = DropdownManager.getInstance();

    // Handle trigger clicks
    document.querySelectorAll('[data-dropdown-trigger]').forEach(trigger => {
      trigger.addEventListener('click', (e) => {
        e.stopPropagation();
        const dropdownId = (trigger as HTMLElement).dataset.dropdownTrigger;
        if (dropdownId) {
          manager.toggleDropdown(dropdownId);
        }
      });
    });

    // Handle dropdown option clicks
    document.querySelectorAll('.dropdown-option').forEach(option => {
      option.addEventListener('click', (e) => {
        e.stopPropagation();
        
        // Find which dropdown this option belongs to
        const content = option.closest('[data-dropdown-content]');
        const dropdownId = (content as HTMLElement)?.dataset.dropdownContent;
        
        if (dropdownId) {
          // Close dropdown after selection
          setTimeout(() => {
            manager.closeDropdownById(dropdownId);
          }, 100);
        }
      });
    });

    // Close dropdowns when clicking outside
    document.addEventListener('click', () => {
      manager.closeAll();
    });

    // Close dropdowns on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        manager.closeAll();
      }
    });
  });

  // Export manager for external use
  (window as any).DropdownManager = DropdownManager;
</script>