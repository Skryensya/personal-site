---
// GameOfLifeBackground - A clean Game of Life implementation for backgrounds
// No UI controls, covers full viewport
// Auto-shows on 404 page, hidden by default but shows with Konami code on other pages

interface Props {
    is404Page?: boolean;
}

const { is404Page = false } = Astro.props;
---

<div class={`fixed inset-0 -z-10 ${is404Page ? 'block' : 'hidden'}`} id="gameOfLifeBackgroundContainer" data-is-404={is404Page ? 'true' : 'false'}>
    <canvas
        id="gameOfLifeBackgroundCanvas"
        class="w-full h-full bg-transparent"
        style="filter: blur(0.5px);"
    ></canvas>
</div>

<script>
// @ts-nocheck
class GameOfLifeBackground {
    constructor() {
        this.canvas = document.getElementById('gameOfLifeBackgroundCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.cellSize = 10;
        this.speed = 120;
        this.isRunning = true;
        this.lastUpdateTime = 0;
        this.animationId = null;
        this.gap = 1;
        this.isDrawing = false;
        this.drawMode = null;
        
        // Check if this is a 404 page
        const container = this.canvas.closest('[data-is-404]');
        this.is404Page = container && container.getAttribute('data-is-404') === 'true';
        
        // Responsive properties
        this.resizeObserver = null;
        this.resizeTimeout = null;
        this.pixelRatio = window.devicePixelRatio || 1;
        this.needsResize = false;
        
        // Parallax properties
        this.parallaxOffset = { x: 0, y: 0 };
        this.lastScrollTop = 0;
        this.lastScrollLeft = 0;
        
        
        this.setupCanvas();
        this.initializeGrid();
        this.randomizeGrid();
        
        // Always start with random pattern and running
        this.isRunning = true;
        
        this.setupEventListeners();
        this.setupParallax();
        this.startRenderLoop();
    }
    
    setupCanvas() {
        // Get viewport dimensions
        const displayWidth = window.innerWidth;
        const displayHeight = window.innerHeight;
        
        // Set canvas size with pixel ratio consideration
        const canvasWidth = Math.floor(displayWidth * this.pixelRatio);
        const canvasHeight = Math.floor(displayHeight * this.pixelRatio);
        
        if (this.canvas.width !== canvasWidth || this.canvas.height !== canvasHeight) {
            this.canvas.width = canvasWidth;
            this.canvas.height = canvasHeight;
            
            // Style for CSS size
            this.canvas.style.width = displayWidth + 'px';
            this.canvas.style.height = displayHeight + 'px';
            
            // Scale context
            this.ctx.scale(this.pixelRatio, this.pixelRatio);
            
            // Calculate grid dimensions
            this.cols = Math.floor(displayWidth / this.cellSize);
            this.rows = Math.floor(displayHeight / this.cellSize);
            
            this.needsResize = true;
        }
        
        this.ctx.imageSmoothingEnabled = false;
        this.setupResizeObserver();
    }
    
    setupResizeObserver() {
        if (!this.resizeObserver) {
            this.resizeObserver = new ResizeObserver(() => {
                clearTimeout(this.resizeTimeout);
                this.resizeTimeout = setTimeout(() => {
                    this.handleResize();
                }, 100);
            });
            
            this.resizeObserver.observe(document.body);
        }
    }
    
    handleResize() {
        const oldCols = this.cols;
        const oldRows = this.rows;
        
        this.setupCanvas();
        
        if (this.needsResize && (oldCols !== this.cols || oldRows !== this.rows)) {
            this.handleGridResize(oldCols, oldRows);
            this.needsResize = false;
        }
    }
    
    handleGridResize(oldCols, oldRows) {
        if (!this.grid || !oldCols || !oldRows) {
            this.initializeGrid();
            this.randomizeGrid();
            return;
        }
        
        const newGrid = [];
        const newNextGrid = [];
        
        for (let i = 0; i < this.rows; i++) {
            newGrid[i] = [];
            newNextGrid[i] = [];
            for (let j = 0; j < this.cols; j++) {
                if (i < oldRows && j < oldCols && this.grid[i] && this.grid[i][j]) {
                    newGrid[i][j] = { alive: this.grid[i][j].alive };
                } else {
                    newGrid[i][j] = { alive: false };
                }
                newNextGrid[i][j] = { alive: false };
            }
        }
        
        this.grid = newGrid;
        this.nextGrid = newNextGrid;
        // Keep existing patterns after resize
    }
    
    initializeGrid() {
        this.grid = [];
        this.nextGrid = [];
        
        for (let i = 0; i < this.rows; i++) {
            this.grid[i] = [];
            this.nextGrid[i] = [];
            for (let j = 0; j < this.cols; j++) {
                this.grid[i][j] = { alive: false };
                this.nextGrid[i][j] = { alive: false };
            }
        }
    }
    
    randomizeGrid() {
        for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.cols; j++) {
                this.grid[i][j].alive = Math.random() < 0.15;
            }
        }
    }
    
    setupEventListeners() {
        if (this.is404Page) {
            // On 404 page, just mouse hover creates cells
            this.canvas.addEventListener('mousemove', (e) => {
                this.handleMouseHover(e);
            });
        } else {
            // On other pages, click and drag to draw cells
            this.canvas.addEventListener('mousedown', (e) => {
                this.isDrawing = true;
                this.drawMode = null;
                this.handleCanvasClick(e);
            });
            
            this.canvas.addEventListener('mousemove', (e) => {
                if (this.isDrawing) {
                    this.handleCanvasClick(e);
                }
            });
            
            this.canvas.addEventListener('mouseup', () => {
                this.isDrawing = false;
                this.drawMode = null;
            });
            
            this.canvas.addEventListener('mouseleave', () => {
                this.isDrawing = false;
                this.drawMode = null;
            });
        }
        
        // Prevent context menu
        this.canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
    }
    
    handleCanvasClick(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left + this.parallaxOffset.x;
        const y = e.clientY - rect.top + this.parallaxOffset.y;
        
        const col = Math.floor(x / this.cellSize);
        const row = Math.floor(y / this.cellSize);
        
        if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
            // Determine drawing mode on first click
            if (this.drawMode === null) {
                this.drawMode = this.grid[row][col].alive ? 'deactivate' : 'activate';
            }
            
            // Apply drawing mode
            if (this.drawMode === 'activate') {
                this.grid[row][col].alive = true;
            } else {
                this.grid[row][col].alive = false;
            }
        }
    }
    
    handleMouseHover(e) {
        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left + this.parallaxOffset.x;
        const y = e.clientY - rect.top + this.parallaxOffset.y;
        
        const col = Math.floor(x / this.cellSize);
        const row = Math.floor(y / this.cellSize);
        
        if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
            // Create cells on hover (404 page only)
            // Add some randomness to make it more organic
            if (Math.random() < 0.3) {
                this.grid[row][col].alive = true;
                
                // Also activate some neighboring cells occasionally
                if (Math.random() < 0.1) {
                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            const newRow = row + i;
                            const newCol = col + j;
                            if (newRow >= 0 && newRow < this.rows && newCol >= 0 && newCol < this.cols) {
                                if (Math.random() < 0.5) {
                                    this.grid[newRow][newCol].alive = true;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    setupParallax() {
        // Add scroll listener for parallax effect
        this.handleScroll = this.handleScroll.bind(this);
        window.addEventListener('scroll', this.handleScroll, { passive: true });
        window.addEventListener('resize', this.handleScroll, { passive: true });
    }
    
    handleScroll() {
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
        const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
        
        // Calculate parallax offset (slower movement than scroll)
        const parallaxFactor = 0.3; // Adjust this value to control parallax intensity
        
        this.parallaxOffset.y = scrollTop * parallaxFactor;
        this.parallaxOffset.x = scrollLeft * parallaxFactor;
        
        this.lastScrollTop = scrollTop;
        this.lastScrollLeft = scrollLeft;
    }
    
    
    countNeighbors(row, col) {
        let count = 0;
        for (let i = -1; i <= 1; i++) {
            for (let j = -1; j <= 1; j++) {
                if (i === 0 && j === 0) continue;
                
                const newRow = row + i;
                const newCol = col + j;
                
                if (newRow >= 0 && newRow < this.rows && newCol >= 0 && newCol < this.cols) {
                    if (this.grid[newRow][newCol].alive) count++;
                }
            }
        }
        return count;
    }
    
    updateGrid() {
        for (let i = 0; i < this.rows; i++) {
            for (let j = 0; j < this.cols; j++) {
                const neighbors = this.countNeighbors(i, j);
                const currentCell = this.grid[i][j];
                
                if (currentCell.alive) {
                    this.nextGrid[i][j].alive = neighbors === 2 || neighbors === 3;
                } else {
                    this.nextGrid[i][j].alive = neighbors === 3;
                }
            }
        }
        
        [this.grid, this.nextGrid] = [this.nextGrid, this.grid];
    }
    
    draw() {
        const displayWidth = window.innerWidth;
        const displayHeight = window.innerHeight;
        
        // Clear with transparent background
        this.ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        // Apply parallax transform
        this.ctx.save();
        this.ctx.translate(-this.parallaxOffset.x, -this.parallaxOffset.y);
        
        // Get theme color
        const computedStyle = getComputedStyle(document.documentElement);
        const mainColor = computedStyle.getPropertyValue('--color-main').trim() || '#000000';
        
        // Draw very faint grid with parallax
        this.ctx.strokeStyle = mainColor;
        this.ctx.globalAlpha = 0.03;
        this.ctx.lineWidth = 0.5;
        
        // Calculate grid boundaries with some extra margin for parallax
        const margin = 100;
        const startCol = Math.max(0, Math.floor(this.parallaxOffset.x / this.cellSize) - margin);
        const endCol = Math.min(this.cols, Math.ceil((this.parallaxOffset.x + displayWidth) / this.cellSize) + margin);
        const startRow = Math.max(0, Math.floor(this.parallaxOffset.y / this.cellSize) - margin);
        const endRow = Math.min(this.rows, Math.ceil((this.parallaxOffset.y + displayHeight) / this.cellSize) + margin);
        
        // Vertical lines (only draw visible ones)
        for (let j = startCol; j <= endCol; j++) {
            const x = j * this.cellSize;
            this.ctx.beginPath();
            this.ctx.moveTo(x, startRow * this.cellSize);
            this.ctx.lineTo(x, endRow * this.cellSize);
            this.ctx.stroke();
        }
        
        // Horizontal lines (only draw visible ones)
        for (let i = startRow; i <= endRow; i++) {
            const y = i * this.cellSize;
            this.ctx.beginPath();
            this.ctx.moveTo(startCol * this.cellSize, y);
            this.ctx.lineTo(endCol * this.cellSize, y);
            this.ctx.stroke();
        }
        
        // Draw alive cells with parallax
        this.ctx.globalAlpha = 0.4;
        this.ctx.fillStyle = mainColor;
        
        for (let i = startRow; i < endRow; i++) {
            for (let j = startCol; j < endCol; j++) {
                if (i >= 0 && i < this.rows && j >= 0 && j < this.cols && this.grid[i][j].alive) {
                    const x = j * this.cellSize + this.gap;
                    const y = i * this.cellSize + this.gap;
                    const size = this.cellSize - (this.gap * 2);
                    this.ctx.fillRect(x, y, size, size);
                }
            }
        }
        
        this.ctx.restore();
    }
    
    startRenderLoop() {
        const renderFrame = (currentTime) => {
            // Update simulation
            if (this.isRunning && currentTime - this.lastUpdateTime >= this.speed) {
                this.updateGrid();
                this.lastUpdateTime = currentTime;
            }
            
            this.draw();
            this.animationId = requestAnimationFrame(renderFrame);
        };
        
        this.animationId = requestAnimationFrame(renderFrame);
    }
    
    destroy() {
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
            this.resizeObserver = null;
        }
        
        if (this.resizeTimeout) {
            clearTimeout(this.resizeTimeout);
            this.resizeTimeout = null;
        }
        
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }
        
        // Remove parallax scroll listener
        if (this.handleScroll) {
            window.removeEventListener('scroll', this.handleScroll);
            window.removeEventListener('resize', this.handleScroll);
        }
    }
}

// Konami Code implementation
class KonamiCode {
    constructor(callback) {
        this.sequence = [
            'ArrowUp', 'ArrowUp', 
            'ArrowDown', 'ArrowDown',
            'ArrowLeft', 'ArrowRight', 
            'ArrowLeft', 'ArrowRight',
            'KeyB', 'KeyA'
        ];
        this.userSequence = [];
        this.callback = callback;
        this.isListening = true;
        
        this.handleKeydown = this.handleKeydown.bind(this);
        document.addEventListener('keydown', this.handleKeydown);
    }
    
    handleKeydown(event) {
        if (!this.isListening) return;
        
        this.userSequence.push(event.code);
        
        // Keep only the last N keys where N is the length of the Konami code
        if (this.userSequence.length > this.sequence.length) {
            this.userSequence.shift();
        }
        
        // Check if the sequence matches
        if (this.userSequence.length === this.sequence.length) {
            const match = this.userSequence.every((key, index) => key === this.sequence[index]);
            if (match) {
                this.callback();
                this.userSequence = []; // Reset after successful match
            }
        }
    }
    
    destroy() {
        document.removeEventListener('keydown', this.handleKeydown);
        this.isListening = false;
    }
}

// Global instances
let backgroundGameInstance = null;
let konamiInstance = null;

function initializeBackground() {
    if (backgroundGameInstance) {
        backgroundGameInstance.destroy();
    }
    
    const canvas = document.getElementById('gameOfLifeBackgroundCanvas');
    if (canvas) {
        backgroundGameInstance = new GameOfLifeBackground();
    }
}

function initializeKonami() {
    if (konamiInstance) {
        konamiInstance.destroy();
    }
    
    // Only initialize Konami code if we're not on a 404 page
    const container = document.getElementById('gameOfLifeBackgroundContainer');
    const is404 = container && container.getAttribute('data-is-404') === 'true';
    
    if (!is404) {
        konamiInstance = new KonamiCode(() => {
            // Show the Game of Life background
            if (container) {
                container.classList.remove('hidden');
                // Initialize if not already done
                if (!backgroundGameInstance) {
                    initializeBackground();
                }
            }
        });
    }
}

// Initialize everything
document.addEventListener('DOMContentLoaded', () => {
    initializeBackground();
    initializeKonami();
});

// Handle theme changes and page navigation
document.addEventListener('astro:after-swap', () => {
    initializeBackground();
    initializeKonami();
});

// Cleanup on unload
window.addEventListener('beforeunload', () => {
    if (backgroundGameInstance) {
        backgroundGameInstance.destroy();
        backgroundGameInstance = null;
    }
    if (konamiInstance) {
        konamiInstance.destroy();
        konamiInstance = null;
    }
});
</script>