---
export interface Props {
    class?: string;
    showControls?: boolean;
}

const { 
    class: className, 
    showControls = false
} = Astro.props;
---

<div class:list={['ascii-grid-wrapper', className]}>
    {showControls && (
        <div class="color-controls">
            <label>
                Color Principal:
                <input type="color" id="primaryColorPicker" value="#000000" />
            </label>
            <label>
                Color Secundario:
                <input type="color" id="secondaryColorPicker" value="#ffffff" />
            </label>
        </div>
    )}
    <canvas id="techGridCanvas"></canvas>
</div>

<style>
    .ascii-grid-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: transparent;
    }

    #techGridCanvas {
        display: block;
        width: 100%;
        height: 100%;
        background: transparent;
    }

    .color-controls {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 10;
        background: rgb(var(--color-bg));
        color: rgb(var(--color-text-main));
        padding: 12px;
        border: 1px solid rgb(var(--color-text-main));
        border-radius: 4px;
        font-family: 'Courier New', monospace;
        font-size: 11px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    /* Hide controls on mobile devices */
    @media (max-width: 768px) {
        .color-controls {
            display: none;
        }
    }

    .color-controls label {
        display: block;
        margin-bottom: 8px;
        font-weight: 500;
    }

    .color-controls input[type="color"] {
        width: 40px;
        height: 20px;
        border: none;
        margin-left: 8px;
        cursor: pointer;
    }
</style>

<script>
    function initAsciiGrid() {
        const canvas = document.getElementById('techGridCanvas') as HTMLCanvasElement;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        if (!ctx) return;

        // Configuración de la cuadrícula técnica
        const GRID_CONFIG = {
            baseSpacing: 8,           // Más denso
            baseSize: 6,              // Letras más pequeñas
            maxSizeMultiplier: 2.2,   // Crecimiento moderado
            influenceRadius: 200,     // Radio de influencia balanceado
            pushDistance: 50,         // Empuje más suave
            smoothing: 0.25,          // Transiciones más rápidas para respuesta inmediata
            falloffPower: 1.4         // Falloff más definido
        };

        // Caracteres ASCII para malla técnica
        const ASCII_MESH = {
            MAIN_INTERSECTION: '+',
            HORIZONTAL_LINE: '─',
            VERTICAL_LINE: '│',
            MINOR_DOT: '·'
        };

        // Pesos visuales jerárquicos
        const VISUAL_WEIGHTS = {
            MAIN_INTERSECTION: 1.2,
            HORIZONTAL_LINE: 0.8,
            VERTICAL_LINE: 0.8,
            MINOR_DOT: 0.6
        };

        // Tipos
        interface GridElement {
            baseX: number;
            baseY: number;
            x: number;
            y: number;
            char: string;
            weight: number;
            size: number;
            influence: number;
        }

        // Estado del grid
        let gridElements: GridElement[] = [];
        let mouseX: number = 0;
        let mouseY: number = 0;
        let lastFrameTime: number = 0;
        let animationId: number = 0;
        let isMouseHovering: boolean = false;
        let animationTime: number = 0;
        let currentPattern: number = 0;
        let nextPattern: number = 1;
        let patternSwitchTime: number = 0;
        let transitionProgress: number = 0;
        let isTransitioning: boolean = false;
        
        // Estado para transición suave al salir el mouse
        let isTransitioningToAnimation: boolean = false;
        let transitionToAnimationProgress: number = 0;
        let transitionStartMouseX: number = 0;
        let transitionStartMouseY: number = 0;

        // Cache para colores del tema
        let cachedTextColor: string = '#000000';
        let lastColorCheck: number = 0;
        const COLOR_CHECK_INTERVAL = 100; // Check every 100ms

        function getThemeColors(): string {
            const now = performance.now();
            
            // Solo actualizar colores cada cierto tiempo para mejor rendimiento
            if (now - lastColorCheck > COLOR_CHECK_INTERVAL) {
                const style = getComputedStyle(document.documentElement);
                const colorMain = style.getPropertyValue('--color-main').trim();
                
                if (colorMain) {
                    cachedTextColor = colorMain;
                } else {
                    cachedTextColor = '#000000';
                }
                
                lastColorCheck = now;
            }
            
            return cachedTextColor;
        }

        function resizeCanvas(): void {
            if (!ctx) return;
            
            const rect = canvas.getBoundingClientRect();
            const devicePixelRatio = window.devicePixelRatio || 1;
            
            // Ajustar para alta densidad de píxeles
            canvas.width = rect.width * devicePixelRatio;
            canvas.height = rect.height * devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            // Escalar el contexto para alta densidad
            ctx.scale(devicePixelRatio, devicePixelRatio);
            
            mouseX = rect.width / 2;
            mouseY = rect.height / 2;
        }

        function generateTechGrid(): void {
            gridElements = [];
            const rect = canvas.getBoundingClientRect();
            const cols = Math.floor(rect.width / GRID_CONFIG.baseSpacing);
            const rows = Math.floor(rect.height / GRID_CONFIG.baseSpacing);

            for (let col = 0; col <= cols; col++) {
                for (let row = 0; row <= rows; row++) {
                    const x = col * GRID_CONFIG.baseSpacing;
                    const y = row * GRID_CONFIG.baseSpacing;

                    let char;
                    let weight = 1;

                    if (col % 4 === 0 && row % 4 === 0) {
                        char = ASCII_MESH.MAIN_INTERSECTION;
                        weight = VISUAL_WEIGHTS.MAIN_INTERSECTION;
                    } else if (col % 4 === 0) {
                        char = ASCII_MESH.VERTICAL_LINE;
                        weight = VISUAL_WEIGHTS.VERTICAL_LINE;
                    } else if (row % 4 === 0) {
                        char = ASCII_MESH.HORIZONTAL_LINE;
                        weight = VISUAL_WEIGHTS.HORIZONTAL_LINE;
                    } else if (col % 2 === 0 && row % 2 === 0) {
                        char = ASCII_MESH.MINOR_DOT;
                        weight = VISUAL_WEIGHTS.MINOR_DOT;
                    } else {
                        continue;
                    }

                    gridElements.push({
                        baseX: x,
                        baseY: y,
                        x: x,
                        y: y,
                        char: char,
                        weight: weight,
                        size: GRID_CONFIG.baseSize * weight,
                        influence: 0
                    });
                }
            }
        }

        function setupEventListeners(): void {
            // Check if device is mobile
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                           ('ontouchstart' in window) ||
                           (navigator.maxTouchPoints > 0);
            
            // Only add mouse event listeners on desktop
            if (!isMobile) {
                // Optimizar eventos de mouse usando throttling
                let isMouseMoving = false;
                
                canvas.addEventListener('mousemove', (e: MouseEvent) => {
                    if (!isMouseMoving) {
                        isMouseMoving = true;
                        requestAnimationFrame(() => {
                            const rect = canvas.getBoundingClientRect();
                            mouseX = e.clientX - rect.left;
                            mouseY = e.clientY - rect.top;
                            isMouseMoving = false;
                        });
                    }
                });

                canvas.addEventListener('mouseleave', () => {
                    // Iniciar transición suave de vuelta a la animación
                    isMouseHovering = false;
                    isTransitioningToAnimation = true;
                    transitionToAnimationProgress = 0;
                    transitionStartMouseX = mouseX;
                    transitionStartMouseY = mouseY;
                });

                canvas.addEventListener('mouseenter', (e: MouseEvent) => {
                    const rect = canvas.getBoundingClientRect();
                    mouseX = e.clientX - rect.left;
                    mouseY = e.clientY - rect.top;
                    isMouseHovering = true;
                    // Cancelar cualquier transición en progreso
                    isTransitioningToAnimation = false;
                    transitionToAnimationProgress = 0;
                });
            }

            // Debounce resize events
            let resizeTimeout: ReturnType<typeof setTimeout>;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    resizeCanvas();
                    generateTechGrid();
                }, 150);
            });

            // Detectar cambios de tema con menos frecuencia
            const observer = new MutationObserver(() => {
                // Reset color cache cuando cambie el tema
                lastColorCheck = 0;
            });

            observer.observe(document.documentElement, {
                attributes: true,
                attributeFilter: ['class', 'data-theme']
            });
        }

        // Pre-calcular valores para optimización
        let cachedRect = { width: 0, height: 0 };
        let rectUpdateTime = 0;
        let lastMouseX = -1000;
        let lastMouseY = -1000;
        let frameSkipCounter = 0;
        
        // Cache para efectos de compresión
        const compressionCache = new Map();
        let compressionCacheTime = 0;

        function renderFrame(currentTime: number): void {
            if (!ctx) return;
            
            // Calcular delta time para animaciones consistentes
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            
            // Skip frames if performance is poor (adaptive FPS)
            frameSkipCounter++;
            if (frameSkipCounter % 2 === 0 && deltaTime < 8) { // Skip every other frame if running too fast
                animationId = requestAnimationFrame(renderFrame);
                return;
            }
            frameSkipCounter = 0;
            
            // Cache rect updates
            if (currentTime - rectUpdateTime > 100) { // Update rect every 100ms max
                const rect = canvas.getBoundingClientRect();
                cachedRect.width = rect.width;
                cachedRect.height = rect.height;
                rectUpdateTime = currentTime;
            }
            
            // Handle smooth transition back to animation when mouse leaves
            if (isTransitioningToAnimation) {
                transitionToAnimationProgress += deltaTime / 800; // 800ms transition duration
                
                // Calculate target position from animation pattern
                const centerX = cachedRect.width * 0.5;
                const centerY = cachedRect.height * 0.5;
                const scale = 100;
                const targetPos = getPatternPosition(currentPattern, centerX, centerY, scale, animationTime);
                
                // Smooth easing function (ease-out cubic)
                const t = Math.min(transitionToAnimationProgress, 1);
                const easeProgress = 1 - Math.pow(1 - t, 3);
                
                // Interpolate from start position to target animation position
                mouseX = transitionStartMouseX + (targetPos.x - transitionStartMouseX) * easeProgress;
                mouseY = transitionStartMouseY + (targetPos.y - transitionStartMouseY) * easeProgress;
                
                // End transition when complete
                if (transitionToAnimationProgress >= 1) {
                    isTransitioningToAnimation = false;
                    transitionToAnimationProgress = 0;
                }
            }
            
            // Multiple animation patterns
            if (!isMouseHovering && !isTransitioningToAnimation) {
                animationTime += deltaTime * 0.0008; // Slow animation speed
                patternSwitchTime += deltaTime;
                
                // Switch pattern every 10 seconds with 1 second transition
                if (patternSwitchTime > 9000 && !isTransitioning) {
                    isTransitioning = true;
                    transitionProgress = 0;
                    
                    // Pick random next pattern (different from current)
                    do {
                        nextPattern = Math.floor(Math.random() * 5);
                    } while (nextPattern === currentPattern && currentPattern !== 0); // Prevent infinite loop
                }
                
                if (isTransitioning) {
                    transitionProgress += deltaTime / 1000; // 1 second transition
                    
                    if (transitionProgress >= 1) {
                        currentPattern = nextPattern;
                        isTransitioning = false;
                        patternSwitchTime = 0;
                        transitionProgress = 0;
                    }
                }
                
                const centerX = cachedRect.width * 0.5;
                const centerY = cachedRect.height * 0.5;
                const scale = 100;
                
                // Optimized pattern position calculation
                let newMouseX, newMouseY;
                
                if (isTransitioning) {
                    // Smooth transition using pre-calculated easing
                    const t = transitionProgress;
                    const easeProgress = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 3) * 0.5;
                    
                    // Pre-calculate both positions
                    const [currentPos, nextPos] = getPatternPositions(currentPattern, nextPattern, centerX, centerY, scale, animationTime);
                    
                    newMouseX = currentPos.x + (nextPos.x - currentPos.x) * easeProgress;
                    newMouseY = currentPos.y + (nextPos.y - currentPos.y) * easeProgress;
                } else {
                    const pos = getPatternPosition(currentPattern, centerX, centerY, scale, animationTime);
                    newMouseX = pos.x;
                    newMouseY = pos.y;
                }
                
                mouseX = newMouseX;
                mouseY = newMouseY;
            }
            
            // Continue animation time even during transition to keep patterns moving
            if (!isMouseHovering) {
                animationTime += deltaTime * 0.0008;
            }
            
            // Only update if mouse moved significantly or if we're in transition
            const mouseMoved = Math.abs(mouseX - lastMouseX) > 1 || Math.abs(mouseY - lastMouseY) > 1;
            if (!mouseMoved && isMouseHovering && !isTransitioningToAnimation) {
                animationId = requestAnimationFrame(renderFrame);
                return;
            }
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            
            const textColor = getThemeColors();
            
            // Clear canvas
            ctx.clearRect(0, 0, cachedRect.width, cachedRect.height);

            // Pre-filter visible elements más eficientemente
            const margin = 50;
            const visibleElements = gridElements.filter(element => 
                element.x > -margin && element.x < cachedRect.width + margin && 
                element.y > -margin && element.y < cachedRect.height + margin
            );

            // Batch canvas operations
            ctx.fillStyle = textColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // Pre-calculate mouse distance and influence for all elements
            const mouseInfluences = new Float32Array(visibleElements.length);
            const maxInfluence = GRID_CONFIG.influenceRadius;
            const maxInfluenceSq = maxInfluence * maxInfluence; // Evitar sqrt cuando sea posible
            
            for (let i = 0; i < visibleElements.length; i++) {
                const element = visibleElements[i];
                const dx = mouseX - element.baseX;
                const dy = mouseY - element.baseY;
                const distanceSq = dx * dx + dy * dy;
                
                if (distanceSq > maxInfluenceSq) {
                    mouseInfluences[i] = 0;
                } else {
                    const distance = Math.sqrt(distanceSq);
                    let influence = Math.max(0, 1 - distance / maxInfluence);
                    influence = Math.pow(influence, GRID_CONFIG.falloffPower);
                    mouseInfluences[i] = influence;
                }
            }

            // Update compression cache periodically
            if (currentTime - compressionCacheTime > 50) { // Update every 50ms
                compressionCache.clear();
                compressionCacheTime = currentTime;
            }

            // Process visible elements
            for (let i = 0; i < visibleElements.length; i++) {
                const element = visibleElements[i];
                const targetInfluence = mouseInfluences[i];
                
                // Smooth influence transition
                let smoothingFactor = GRID_CONFIG.smoothing;
                if (targetInfluence < element.influence) {
                    smoothingFactor *= 0.8;
                }
                
                element.influence += (targetInfluence - element.influence) * smoothingFactor;

                // Update size
                const sizeMultiplier = 1 + (element.influence * GRID_CONFIG.maxSizeMultiplier);
                element.size = (GRID_CONFIG.baseSize * element.weight) * sizeMultiplier;

                // Position updates only if significant influence
                if (element.influence > 0.01) {
                    const dx = mouseX - element.baseX;
                    const dy = mouseY - element.baseY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const pushStrength = GRID_CONFIG.pushDistance * element.influence;
                    const pushX = distance > 0 ? (dx / distance) * pushStrength : 0;
                    const pushY = distance > 0 ? (dy / distance) * pushStrength : 0;
                    
                    const gravityFactor = element.influence * element.influence;
                    const extraPushX = pushX * gravityFactor * 0.8;
                    const extraPushY = pushY * gravityFactor * 0.8;
                    
                    const targetX = element.baseX + pushX + extraPushX;
                    const targetY = element.baseY + pushY + extraPushY;
                    
                    const positionSmoothing = smoothingFactor * 1.5;
                    element.x += (targetX - element.x) * positionSmoothing;
                    element.y += (targetY - element.y) * positionSmoothing;
                }

                // Optimized compression effect with caching
                const cacheKey = `${Math.floor(element.baseX / 10)}_${Math.floor(element.baseY / 10)}`;
                let compressionNoise, compression;
                
                if (compressionCache.has(cacheKey)) {
                    const cached = compressionCache.get(cacheKey);
                    compressionNoise = cached.noise;
                    compression = cached.compression;
                } else {
                    compressionNoise = (Math.random() - 0.5) * 0.3;
                    compression = Math.sin(element.baseX * 0.01 + element.baseY * 0.01 + animationTime * 0.002) * 0.2;
                    compressionCache.set(cacheKey, { noise: compressionNoise, compression });
                }
                
                const baseOpacity = 0.3 + (element.influence * 0.6);
                const glitchEffect = Math.random() < 0.05 ? (Math.random() - 0.5) * 0.4 : 0;
                const opacity = Math.max(0.1, Math.min(1, baseOpacity + compressionNoise + compression + glitchEffect));

                // Minimize canvas state changes
                ctx.globalAlpha = opacity;
                ctx.font = `${Math.round(element.size)}px 'Courier New', monospace`;
                ctx.fillText(element.char, Math.round(element.x), Math.round(element.y));
            }

            // Restore alpha
            ctx.globalAlpha = 1;

            // Optimized cursor rendering
            ctx.strokeStyle = textColor;
            
            if (isMouseHovering) {
                ctx.globalAlpha = 0.8;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 8, 0, Math.PI * 2);
                ctx.stroke();
            } else {
                const pulseAlpha = 0.5 + Math.sin(currentTime * 0.002) * 0.2;
                ctx.globalAlpha = pulseAlpha;
                ctx.lineWidth = 1.5 + Math.sin(currentTime * 0.003) * 0.5;
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 6 + Math.sin(currentTime * 0.0025) * 1.5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;

            animationId = requestAnimationFrame(renderFrame);
        }

        // Optimized pattern position functions
        function getPatternPosition(pattern: number, centerX: number, centerY: number, scale: number, time: number): {x: number, y: number} {
            switch (pattern) {
                case 0: // Figure-8
                    return {
                        x: centerX + scale * 1.2 * Math.sin(time),
                        y: centerY + scale * 0.4 * Math.sin(time * 2)
                    };
                case 1: // Circle
                    return {
                        x: centerX + scale * Math.cos(time),
                        y: centerY + scale * Math.sin(time)
                    };
                case 2: // Triangle
                    const phase = (time % (Math.PI * 2)) / (Math.PI * 2);
                    const t = (phase % (1/3)) * 3;
                    if (phase < 1/3) return { x: centerX + scale * (-0.5 + t), y: centerY + scale * (0.5 - t * 1.5) };
                    if (phase < 2/3) return { x: centerX + scale * (0.5 - t), y: centerY + scale * (-1) };
                    return { x: centerX + scale * (-0.5), y: centerY + scale * (-1 + t * 1.5) };
                case 3: // Star
                    const starPhase = (time % (Math.PI * 2)) / (Math.PI * 2);
                    const segment = Math.floor(starPhase * 10) % 10;
                    const segmentT = (starPhase * 10) % 1;
                    const radius = (segment % 2 === 0) ? scale + (scale * 0.4 - scale) * segmentT : scale * 0.4 + (scale - scale * 0.4) * segmentT;
                    const angle = (segment * 0.1 + (segment % 2 === 0 ? 0 : 0.05)) * Math.PI * 2 - Math.PI * 0.5;
                    return { x: centerX + radius * Math.cos(angle), y: centerY + radius * Math.sin(angle) };
                case 4: // Letter A
                    const aPhase = (time % (Math.PI * 2)) / (Math.PI * 2);
                    const aScale = scale * 0.8;
                    const at = (aPhase % 0.25) * 4;
                    if (aPhase < 0.25) return { x: centerX + aScale * (-0.5 + at * 0.5), y: centerY + aScale * (1 - at * 2) };
                    if (aPhase < 0.5) return { x: centerX + aScale * (at * 0.5), y: centerY + aScale * (-1 + at * 2) };
                    if (aPhase < 0.75) return { x: centerX + aScale * (0.5 - at), y: centerY };
                    return { x: centerX + aScale * (-0.5), y: centerY + aScale * (at) };
                default:
                    return {x: centerX, y: centerY};
            }
        }

        function getPatternPositions(pattern1: number, pattern2: number, centerX: number, centerY: number, scale: number, time: number): [{x: number, y: number}, {x: number, y: number}] {
            return [
                getPatternPosition(pattern1, centerX, centerY, scale, time),
                getPatternPosition(pattern2, centerX, centerY, scale, time)
            ];
        }

        // Inicialización
        resizeCanvas();
        generateTechGrid();
        setupEventListeners();
        
        // Iniciar loop de animación
        lastFrameTime = performance.now();
        animationId = requestAnimationFrame(renderFrame);
        
        // Cleanup en caso de que el componente se desmonte
        return () => {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        };
    }

    // Inicializar en carga inicial
    document.addEventListener('DOMContentLoaded', initAsciiGrid);
    
    // Inicializar en navegación de Astro
    document.addEventListener('astro:page-load', initAsciiGrid);
    
    // Cleanup en navegación de Astro
    document.addEventListener('astro:before-preparation', () => {
        const canvas = document.getElementById('techGridCanvas') as HTMLCanvasElement;
        if (canvas) {
            // Limpiar cualquier animación en curso
            const ctx = canvas.getContext('2d');
            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }
    });
</script>